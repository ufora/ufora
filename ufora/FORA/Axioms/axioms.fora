/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
(`Exception): fun(_) {
	let Exception = 
		#Markdown("""
		### Exception

		#### Description

		A base class-mixin for all builtin exception types.
		""")
		class {
			member message;
			operator match(Exception _) { (message,) };
            convert(String) {
                "%s".format(message)
                };

			static InvalidBinaryOperator: 
				class {
					member op;
					member lhs;
					member rhs;
					operator match(cls _) { (op: op, lhs: lhs, rhs: rhs) };
					convert(String) { 
						"Can't apply operator %s to values %s and %s"
							.format(op, lhs, rhs)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidLeftOperator: 
				class {
					member op;
					member rhs;
					operator match(cls _) { (op: op, rhs: rhs) };
					convert(String) { 
						"Can't apply left operator %s to value %s"
							.format(op, rhs)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidRightOperator: 
				class {
					member op;
					member lhs;
					operator match(cls _) { (op: op, lhs: lhs) };
					convert(String) { 
						"Can't apply right operator %s to value %s"
							.format(op, lhs)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidCall:
				class {
					member callee;
					member args;
					operator match(cls _) { (callee: callee, args: args) };
					convert(String) { 
						let tr = "Can't call %s with arguments %s"
							.format(callee, args);

						tr = tr + ":\n\n" + 
							try {
								"valid call signatures for %s are \n".format(callee) +
								`ExtractCallSignatures(`TypeJOV(callee))
								}
							catch (...) {
								"value %s is not callable".format(callee)
								}
						tr
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidConversion:
				class {
					member toConvert;
					member targetType;
					operator match(cls _) { (toConvert: toConvert, targetType: targetType) };
					convert(String) { 
						"Can't convert %s to target type %s"
							.format(toConvert, targetType)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidMemberAccess: 
				class {
					member value;
					member memberName;
					operator match(cls _) { (value: value, memberName: memberName) };
					convert(String) { 
						"Can't access member %s of value %s"
							.format(memberName, value)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidApply:
				class {
					member args;
					operator match(cls _) { (args: args) };
					convert(String) { 
						"Can't perform apply operation:  %s`(%s)"
							.format(args[0], ",".join(args[1,]))
						};
					operator match(Exception _) { (String(self),) }
					};

			static AssertionError:
				class {
					member msg;
					operator match(cls _) { (msg: msg) };
					convert(String) { 
						"%s"
							.format(msg)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidIterator:
				class {
					member arg;
					operator match(cls _) { (arg: arg) };
					convert(String) { 
						"Invalid iterator argument: %s"
							.format(arg)
						};
					operator match(Exception _) { (String(self),) }
					};

			static InvalidPatternMatch:
				class {
					member toMatch;
					operator match(cls _) { (toMatch: toMatch) };
					convert(String) { 
						"Pattern couldn't match value %s".format(toMatch)
						};
					operator match(Exception _) { (String(self),) }
					};			
			};

	Exception
	};

//convert LogMessage argument into a string.
(`LogMessage, `Call, *):
	fun(_,_,x) {
		`LogMessage(String(x))
		}
	;

(`AugmentException, `Call, *, {StackTrace}):
	fun (_,_,(exception, trace if `TypeJOV(trace) is StackTrace), newTrace) {
		return (exception, trace + newTrace)
		}
	   (_,_, exception, newTrace) {
		return (exception, newTrace)
		};

//TODO IDEA brax: idea for a better way to organize the axioms
//
//right now, axioms are organized linearly - we search from start to finish
//this makes it hard to organize them since their physical position affects
//their semantics. Instead, we could tag each axiom with an 'index' stating
//at what level it should operate. Then, we could insist that axioms on
//the same level always be disjoint. That way, we could have a consistent
//hierarchy of axioms (with ordering) without having to maintain the explicit
//ordering we do now. Also, we could put the axioms in separate files without
//having to infer an implicit ordering.

// -----------------------------------------------------------------------------------------------
// DateTime

(DateTime, `Call, ... *):
    fun(_, _, {String} str)
        {
        DateTime.fromString(str)
        }
    (_, _, year:, month:, day:, hours:=0, minutes:=0, seconds:=0)
        {
        let tr = `createDateTime(UInt16(year), UInt16(month), UInt16(day));
        tr = tr + TimeDuration.fromHours(hours);
        tr = tr + TimeDuration.fromMinutes(minutes);
        tr = tr + TimeDuration.fromSeconds(seconds)
        tr
        }
    ;

(DateTime, `Member, `fromString):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.fromString(dateString)

        #### Description

        Parse a string of the form YYYY-MM-DD HH:MM:SS

        #### Example

            DateTime("2012-01-31 12:34:56.789123") is DateTime.fromString("2012-01-31 12:34:56.789123");

        """)
		fun(string)
			{
			`DateTimeFromString(string)
			}
		}
	;

(DateTime, `Member, `fromISOString):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.fromDateString(isoString)

        #### Description

        Parse a string of the form YYYYMMDDTHHMMSS.fffffffff
        Here T is the date-time separator, and should be present.

        #### Example

            DateTime.fromISOString("20120131T123456.789123") // DateTime("2012-Jan-31 12:34:56.789123")

        """)       
		fun(string)
			{
			`DateTimeFromISOString(string)
			}
		}
	;

(DateTime, `Member, `fromDateString):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.fromDateString(dateString)

        #### Description

        Construct a `DateTime` by a date string of the form `YYYY/MM/DD` 
        or `YYYY-MM-DD` or `YYYY MM DD`.

        #### Example

            DateTime("2002/01/25") // givesDateTime("2002-Jan-25 00:00:00");
            DateTime("2002 01 25") // givesDateTime("2002-Jan-25 00:00:00");
            DateTime("2002-01-25") // givesDateTime("2002-Jan-25 00:00:00");

        """)       
		fun(string)
			{
			`DateTimeFromDateString(string)
			}
		}
	;

(DateTime, `Member, `fromUndelimitedDateString):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.fromUndelimitedDateString(undelimitedDateString)

        #### Description

        Construct a `DateTime` by an undelimited date string of the form YYYYMMDD.

        #### Example

            DateTime("20020125") // givesDateTime("2002-Jan-25 00:00:00");
        """)       
		fun(string)
			{
			`DateTimeFromUndelimitedDateString(string)
			}
		}
	;

(DateTime, `Member, `bySecondsSinceEpoch):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.bySecondsSinceEpoch(numSeconds)

        #### Description

        Construct a `DateTime` by the number of seconds since the epoch.

        #### Examples

            DateTime.bySecondsSinceEpoch(12)
        """)       
		fun(seconds)
			{
			`DateTimeByFloatSecondsSinceEpoch(Float64(seconds))
			}
		}
	;

(DateTime, `Member, `strptime):
	fun(_,_,_) {
        #Markdown(
"""
#### Usage 

    DateTime.strptime(dateString, formatString)
    DateTime.strptime((dateString, formatString))

#### Description

Parse a string to a `DateTime` object according to the format `formatString`.

Formatting rules follow the following table:


|specifier|Replaced by|Example|
|---------|-----------|-------|
|%a|Abbreviated weekday name|Thu|
|%A|Full weekday name|Thursday|
|%b|Abbreviated month name|Aug|
|%B|Full month name|August|
|%c|Date and time representation|Thu Aug 23 14:55:02 2001|
|%C|Year divided by 100 and trucated to integer (00-99) (aka, the century number)|20|
|%d|Day of the month, zero-padded (01-31)|23|
|%D|Short MM/DD/YY date, equivalent to %d/%m/%y|01/31/12|
|%e|Day of the month, space-padded ( 1-31)| 23|
|%F|Short YYYY-MM-DD date, equivalent to %Y-%m-%d|2001-08-23|
|%g|Year corresponding to the ISO week number, but without the century (01-99)|01|
|%G|Week-based year|2001|
|%h|Abbreviated month name (same as %b)|Aug|
|%H|Hour in 24th format (00-23)|14|
|%I|Hour in 12h format (01-12)|02|
|%j|Day of the year (001-366)|235|
|%m|Month as a decimal number (01-12)|08|
|%M|Minute (00-59)|55|
|%n|New-line character ('\\n')|'\\n'|
|%p|AM or PM designation|PM|
|%r|12-hour clock time|02-55-02 pm|
|%R|24-hour HH:MM time, equivalent to %H:%M|14:55|
|%S|Second (00-61)|02|
|%t|Horizontal-tab character ('\\t')|'\\t'|
|%T|ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S|14:55:02|
|%u|ISO 8601 weekday as number with Monday as 1 (1-7)|4|
|%U|Week number with the first Sunday as the first day of week one (00-53)|33|
|%V|ISO 8601 week number (00-53)|34|
|%w|Weekday as a decimal number with Sunday as 0 (0-6)|4|
|%W|Week number with the first Monday as the first day of week one (00-53)|34|
|%x|Date representation|08/23/01|
|%X|Time representation|13:55:02|
|%y|Year, last two digits (00-99)|01|
|%Y|Year|2001|
|%%|A % sign|%|

""")
		fun(dateString, formatString)
			{
			`strptime(dateString, formatString)
			}
			((dateString, formatString))
			{
			`strptime(dateString, formatString)
			}
		}
	;

(DateTime, `Member, `epoch):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            DateTime.epoch()

        #### Description

        Returns a `DateTime` representing the "epoch": 1970-Jan-01 00:00:00.
        """)
		fun() { `DateTimeEpoch() }
		}
	;

({DateTime}, `Member, `year):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.year()

        #### Description

        Returns the year of a datetime object.
        """)       
		fun() { dateTime.year_ }
		}
	;

({DateTime}, `Member, `month):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.month()

        #### Description

        Returns the month of a datetime object.
        """)       
		fun() { dateTime.month_ }
		}
	;

({DateTime}, `Member, `day):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.day()

        #### Description

        Returns the day of a datetime object.
        """)       
		fun() { dateTime.day_ }
		}
	;

({DateTime}, `Member, `dayOfWeek):
	fun(dateTime,_,_) {
    #Markdown(
"""
#### Usage

    datetime.dayOfWeek()

#### Description

Returns the day of week of a datetime object.

""")       
		fun() { dateTime.dayOfWeek_ }
		}
	;

({DateTime}, `Member, `timeOfDay):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.timeOfDay()

        #### Description

        Returns the "time part" of a date time.

        #### Examples

            let dt = DateTime.epoch();
            dt.timeOfDay()
            let t = TimeDuration("12:34:56.789123")
            dt = dt + t
            dt.timeOfDay()

        """)       
		fun() { dateTime.timeOfDay_ }
		}
	;

({DateTime}, `Member, `isoString):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.isoString()

        #### Description

        Convert to ISO format: a string of the form YYYYMMDDTHHMMSS.fffffffff
        Here T is the date-time separator.
        """)       
		fun() { dateTime.isoString_ }
		}
	;

({DateTime}, `Member, `isoExtendedString):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

        datetime.isoExtendedString()

        #### Description

        Convert to extended ISO format: a string of the form YYYY-MM-DDTHH:MM:SS.fffffffff
        Here T is the date-time separator.
        """)       
		fun() { dateTime.isoExtendedString_ }
		}
	;

({DateTime}, `Member, `secondsSinceEpoch):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.secondsSinceEpoch()

        #### Description

        Returns the number of seconds since the epoch for `datetime`, as an Int64.
        """)       
		fun() { dateTime.secondsSinceEpoch_ }
		}
	;

({DateTime}, `Member, `floatSecondsSinceEpoch):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.floatSecondsSinceEpoch()

        #### Description

        Returns the number of seconds since the epoch for `datetime`, as a Float64.
        """)       
		fun() { dateTime.floatSecondsSinceEpoch_ }
		}
	;

({DateTime}, `Member, `strftime):
	fun(dateTime,_,_) {
        #Markdown(
"""
#### Usage

    datetime.strftime(format)

#### Description

Format a `DateTime` object `datetime` according to the format `format`.

Formatting rules follow the following table:

|specifier|Replaced by|Example|
|---------|-----------|-------|
|%a|Abbreviated weekday name|Thu|
|%A|Full weekday name|Thursday|
|%b|Abbreviated month name|Aug|
|%B|Full month name|August|
|%c|Date and time representation|Thu Aug 23 14:55:02 2001|
|%C|Year divided by 100 and trucated to integer (00-99) (aka, the century number)|20|
|%d|Day of the month, zero-padded (01-31)|23|
|%D|Short MM/DD/YY date, equivalent to %d/%m/%y|01/31/12|
|%e|Day of the month, space-padded ( 1-31)| 23|
|%F|Short YYYY-MM-DD date, equivalent to %Y-%m-%d|2001-08-23|
|%g|Year corresponding to the ISO week number, but without the century (01-99)|01|
|%G|Week-based year|2001|
|%h|Abbreviated month name (same as %b)|Aug|
|%H|Hour in 24th format (00-23)|14|
|%I|Hour in 12h format (01-12)|02|
|%j|Day of the year (001-366)|235|
|%m|Month as a decimal number (01-12)|08|
|%M|Minute (00-59)|55|
|%n|New-line character ('\\n')|'\\n'|
|%p|AM or PM designation|PM|
|%r|12-hour clock time|02-55-02 pm|
|%R|24-hour HH:MM time, equivalent to %H:%M|14:55|
|%S|Second (00-61)|02|
|%t|Horizontal-tab character ('\\t')|'\\t'|
|%T|ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S|14:55:02|
|%u|ISO 8601 weekday as number with Monday as 1 (1-7)|4|
|%U|Week number with the first Sunday as the first day of week one (00-53)|33|
|%V|ISO 8601 week number (00-53)|34|
|%w|Weekday as a decimal number with Sunday as 0 (0-6)|4|
|%W|Week number with the first Monday as the first day of week one (00-53)|34|
|%x|Date representation|08/23/01|
|%X|Time representation|13:55:02|
|%y|Year, last two digits (00-99)|01|
|%Y|Year|2001|
|%%|A % sign|%|

""")
		fun(format)
			{
			dateTime `(`strftime, format)
			}
		}
	;

({DateTime}, `Member, `timeDurationSinceEpoch):
	fun(dateTime,_,_) {
        #Markdown("""
        #### Usage

            datetime.timeDurationSinceEpoch()

        #### Description

        Returns the time since the epoch for `datetime`, as a `TimeDuration`.
        """)       
		fun()
			{
			dateTime `(`timeDurationSinceEpoch)
			}
		}
	;

({DateTime}, `Operator, `<<<, {DateTime}):
    fun(datetime1, _, _, datetime2) {
        if (datetime1 <= datetime2)
            return datetime1
        return datetime2
        }
    ;

({DateTime}, `Operator, `>>>, {DateTime}):
    fun(datetime1, _, _, datetime2) {
        if (datetime1 >= datetime2)
            return datetime1
        return datetime2
        }
    ;

({DateTime}, `Operator, `!=, {DateTime}):
    fun(datetime1, _, _, datetime2) {
        return !(datetime1 == datetime2)
        }
    ;

// -----------------------------------------------------------------------------------------------
// TimeDuration

({TimeDuration}, `Operator, `<<<, {TimeDuration}):
    fun(timeduration1, _, _, timeduration2) {
        if (timeduration1 <= timeduration2)
            return timeduration1
        return timeduration2
        }
    ;

({TimeDuration}, `Operator, `>>>, {TimeDuration}):
    fun(timeduration1, _, _, timeduration2) {
        if (timeduration1 >= timeduration2)
            return timeduration1
        return timeduration2
        }
    ;

({TimeDuration}, `Operator, `!=, {TimeDuration}):
    fun(timeduration1, _, _, timeduration2) {
        return !(timeduration1 == timeduration2)
        }
    ;

({TimeDuration}, `Operator, `/, {TimeDuration}):
    fun(timeduration1, _, _, timeduration2) {
        return Float64(timeduration1.totalMicroseconds()) / 
            timeduration2.totalMicroseconds();
        }
    ;

({TimeDuration}, `Operator, `*, *):
    fun(timeduration, _, _, x) {
        TimeDuration.fromMicroseconds(
            Int64(Float64(x) * timeduration.totalMicroseconds())
            )
        }
    ;

(*, `Operator, `*, {TimeDuration}):
    fun(x, _, _, timeduration) {
        TimeDuration.fromMicroseconds(
            Int64(Float64(x) * timeduration.totalMicroseconds())
            )
        }
    ;        

({TimeDuration}, `Member, `isNegative):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.isNegative()

        #### Description

        Returns whether or not `TimeDuration` `timeduration` is negative.

        #### Example

            let timeduration = TimeDuration.fromSeconds(1);
            timeduration.isNegative() // true
            (-timeduration).isNegative() // false

        """)       
        fun() { timeduration.isNegative_ }
        }
    ;

({TimeDuration}, `Member, `totalYears):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalYears()

        #### Description

        Return the total number of years (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalWeeks() / 52 }
        }
    ;

({TimeDuration}, `Member, `totalWeeks):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalWeeks()

        #### Description

        Return the total number of weeks (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalDays() / 7 }
        }
    ;

({TimeDuration}, `Member, `totalDays):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalDays()

        #### Description

        Return the total number of days (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalHours() / 24 }
        }
    ;

({TimeDuration}, `Member, `totalHours):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalHours()

        #### Description

        Return the total number of hours (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalMinutes() / 60 } 
        }
    ;

({TimeDuration}, `Member, `totalMinutes):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalMinutes()

        #### Description

        Return the total number of minutes (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalSeconds() / 60 }
        }
    ;

({TimeDuration}, `Member, `totalSeconds):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalSeconds()

        #### Description

        Return the total number of seconds (as an Int64) in `timeduration`.

        """)       
        fun() { timeduration.totalSeconds_ }
        }
    ;

({TimeDuration}, `Member, `totalMilliseconds):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalMilliseconds()

        #### Description

        Return the total number of milliseconds (as an Int64) in `timeduration`.

        """)
        fun() { timeduration.totalMilliseconds_ }
        }
    ;

({TimeDuration}, `Member, `totalMicroseconds):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.totalMicroseconds()

        #### Description

        Return the total number of microseconds (as an Int64) in `timeduration`.

        """)
        fun() { timeduration.totalMicroseconds_ }
        }
    ;

({TimeDuration}, `Member, `fractionalSeconds):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.fractionalSeconds()

        #### Description

        Return the number of fractional (as an Int64) in `timeduration`.

        """)
        fun() { timeduration.fractionalSeconds_ }
        }
    ;

({TimeDuration}, `Member, `hours):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.hours()

        #### Description

        Return the hours part of a timeduration.

        """)
        fun() { timeduration.hours_ }
        }
    ;

({TimeDuration}, `Member, `minutes):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.minutes()

        #### Description

        Return the minutes part of a timeduration.

        """)
        fun() { timeduration.minutes_ }
        }
    ;

({TimeDuration}, `Member, `seconds):
    fun(timeduration,_,_) {
        #Markdown("""
        #### Usage

            timeduration.seconds()

        #### Description

        Return the seconds part of a timeduration.

        """)
        fun() { timeduration.seconds_ }
        }
    ;

(TimeDuration, `Member, `fromString):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromString(string)

        #### Description

        Construct a `TimeDuration` from a string of the form H:M:S

        #### Example

            TimeDuration.fromString("31:41:56.26")

        """)
		fun(string)
			{
			`TimeDurationFromString(string)
			}
		}
	;

(TimeDuration, `Member, `numFractionalDigits):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.numFractionalDigits()

        #### Description

        Return the number of fractional digits in the TimeDuration category.

        """)
		fun()
			{
			TimeDuration.numFractionalDigits_
			}
		}
	;

(TimeDuration, `Member, `fromYears):
    fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromYears(numYears)

        #### Description

        Construct a `TimeDuration` from the number of years.

        """)
        fun(years)
            {
            TimeDuration.fromHours(24 * 365 * years)
            }
        }
    ;

(TimeDuration, `Member, `fromWeeks):
    fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromWeeks(numWeeks)

        #### Description

        Construct a `TimeDuration` from the number of weeks.

        """)
        fun(weeks)
            {
            TimeDuration.fromHours(24 * 7 * weeks)
            }
        }
    ;

(TimeDuration, `Member, `fromDays):
    fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromDays(numDays)

        #### Description

        Construct a `TimeDuration` from the number of days.

        """)
        fun(days)
            {
            TimeDuration.fromHours(24 * days)
            }
        }
    ;

(TimeDuration, `Member, `fromHours):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromHours(numHours)

        #### Description

        Construct a `TimeDuration` from the number of hours.

        """)
		fun(hours)
			{
			TimeDuration.fromMinutes(hours * 60)
			}
		}
	;

(TimeDuration, `Member, `fromMinutes):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromMinutes(numMinutes)

        #### Description

        Construct a `TimeDuration` from the number of minutes.

        """)
		fun(Minutes)
			{
			TimeDuration.fromSeconds(Minutes * 60)
			}
		}
	;

(TimeDuration, `Member, `fromSeconds):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromSeconds(numSeconds)

        #### Description

        Construct a `TimeDuration` from the number of seconds.

        """)
		fun(seconds)
			{
			TimeDuration.fromMilliseconds(seconds * 1000)
			}
		}
	;

(TimeDuration, `Member, `fromMilliseconds):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromMilliseconds(numMilliseconds)

        #### Description

        Construct a `TimeDuration` from the number of milliseconds.

        """)
		fun(milliseconds)
			{
			TimeDuration.fromMicroseconds(milliseconds * 1000)
			}
		}
	;

(TimeDuration, `Member, `fromMicroseconds):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromMicroseconds(numMicroseconds)

        #### Description

        Construct a `TimeDuration` from the number of microseconds.

        """)
		fun(microseconds)
			{
			`TimeDurationFromMicroseconds(Int64(microseconds))
			}
		}
	;

(TimeDuration, `Member, `fromFloat):
	fun(_,_,_) {
        #Markdown("""
        #### Usage

            TimeDuration.fromSeconds(numSeconds)

        #### Description

        Construct a `TimeDuration` from the number of seconds.

        """)
		fun(float)
			{
			`TimeDurationFromFloat(float)
			}
		}
	;


// -----------------------------------------------------------------------------------------------
// Dictionaries

({Dictionary}, `Member, `add):
	fun(dict,_,_) {
		fun(key, value)
			{
			dict `(`AddPair, key, value)
			}
		((key, value))
			{
			dict `(`AddPair, key, value)
			}
		}
	;
({Dictionary}, `Member, `addPair):
	fun(dict,_,_) {
		fun(key, value)
			{
			dict `(`AddPair, key, value)
			}
		((key, value))
			{
			dict `(`AddPair, key, value)
			}
		}
	;
({Dictionary}, `Call, *, *):
	fun(dict, _, key, value)
		{
		dict `(`AddPair, key, value)
		}
	;
({Dictionary}, `Call, (*, *)):
	fun(dict,_,(key, value))
		{
		dict `(`AddPair, key, value)
		}
	;
({Dictionary}, `Operator, `+, (*,*)):
	fun(dict,_,_,(key, value)) {
		dict `(`AddPair, key, value)
		}
	;
({Dictionary}, `Member, `pairAt):
	fun(dict,_,_)
		{
		fun(index)
			{
			dict `(`GetPairAtIndex, index)
			}
		}
	;
({Dictionary}, `Member, `hasKey):
	fun(dict,_,_)
		{
		fun(key)
			{
			dict `(`HasKey, key)
			}
		}
	;
({Dictionary}, `Operator, `in, *):
	fun(dict,_,_,key)
		{
		dict `(`HasKey, key)
		}
	;
({Dictionary}, `Member, `remove):
	fun(dict,_,_)
		{
		fun(key)
			{
			dict `(`RemovePairByKey, key)
			}
		}
	;
({Dictionary}, `Member, `keys):
	fun(dict,_,_)
		{
		fun()
			{
			if (size(dict) == 0) return [];
			return Vector.range(size(dict)).apply(fun(ix){dict.pairAt(ix)[0]})
			}
		}
	;
({Dictionary}, `Member, `values):
	fun(dict,_,_)
		{
		fun()
			{
			if (size(dict) == 0) return [];
			return Vector.range(size(dict)).apply(fun(ix){dict.pairAt(ix)[1]})
			}
		}
	;

// for (key, value) in dict.iter() { ... }
({Dictionary}, `Member, `iter):
	fun(origDict,_,_)
		{
		fun()
			{
			let dict = origDict;
			while (size(dict) > 0)
				{
				let (key, value) = dict.pairAt(0)
				yield (key, value)
				dict = dict.remove(key)
				}
			}
		}
	;

({Dictionary}, `Iter):
	fun(origDict,_)
		{
		let dict = origDict;
		while (size(dict) > 0)
			{
			let (key, value) = dict.pairAt(0)
			yield (key, value)
			dict = dict.remove(key)
			}
		}
	;

({Dictionary}, `Member, `iterEnum):
	fun(dict,_,_)
		{
		fun()
			{
			let k = 0
			let numPairs = size(dict)

			while (k < numPairs)
				{
				yield dict.pairAt(k)
				k = k + 1
				}

			}
		}
	;


// -----------------------------------------------------------------------------------------------
// String interface

"""
#### Usage

    String()

#### Description

Construct an empty String.
"""
(String, `Call):
fun(_, _) { "" };

"""
#### Usage

    for x in "string"

#### Description

Defines the generic iterator for strings.

The string iterator will return, in the above example, each character for the value `x` as a UInt8.
This iterator also enables you to use any of the functions defined in the `iter` builtin library.
"""
({String}, `Iter):
fun(s, _)
    {
    let ix = 0;
    let sz = size(s);
    while (ix < sz) {
        yield s[ix];
        ix = ix + 1
        }
    };

({String}, `Member, `regexReplace):
fun(s, _, _)
	{
#Markdown("""
#### Usage

     string.regexReplace(pattern, replacement)

#### Description

Return the string obtained by replacing the leftmost
non-overlapping occurrences of the pattern `pattern` in 
`string` by the replacement `replacement`.

#### Examples

    let str = "Do or do not, there is no try"  
    str.replaceRegex('(.*),*try', '\\1 \\1 \\1 OH HI')

""")

fun(pattern, replacement)
		{
		s `( `clib_regexReplace, pattern, replacement)
		}
	};

({String}, `Member, `matchesRegex):
fun(s, _, _)
    {
#Markdown("""
#### Usage

    string.matchesRegex(pattern)

#### Description

Return whether the string matches the given regular expression `pattern`.

If `pattern` is not a regular expression, raises an exception. If `string` matches `pattern`, returns
`true, otherwise returns `false`.

#### Examples

    : let str = "Do or do not, there is no try"
    > str.matchesRegex('try')
    > str.matchesRegex('(.*),.*try')
""")
    fun(pattern)
        {
        s `( `MatchesRegex, pattern)
        }
    };

({String}, `Member, `extractRegexMatches):
fun(s, _, _)
    {
#Markdown("""
#### Usage

    string.extractRegexMatches(pattern)

#### Description

Returns a tuple containing the substrings that match the given regular expression `pattern`.

If `pattern` is not a regular expression, raises an exception.  If `string` doesn't match 
`pattern`, returns `nothing`.

#### Examples

    : let str = "Do or do not, there is no try"
    > str.extractRegexMatches('try')
    > str.extractRegexMatches('(.*),.*try')
""")
    fun (pattern)
        {
        s `( `ExtractRegexMatches, pattern)
        }
    };

({String}, `Member, `splitRegex):
fun(s, _, _)
    {
#Markdown("""
#### Usage

    string.splitRegex(pattern)

#### Description

Returns a vector containing the words in the string split by occurrences of `pattern`.

#### Examples:

    "cats123dogs456pigs789rats".splitRegex("[0-9]+")
    "Words, words, words.".splitRegex("\\W+")

""")
    fun(pattern)
        {
        s`(`splitRegex, pattern)
        }
    };

"""
#### Usage

    string[i]

#### Description

Gets the character (as a UInt8) from the given index in the string.

This index `i` is stringified, so values other than integers can be used, as long as the respond to
an Int64 conversion operation.

#### Examples

    > "hello"[0]
    > "hello"["0"]

"""
({String}, `GetItem, *):
fun (s, _, v)
    {
    s[Int64(v)]
    };

"""
#### Usage

    string[i, j]

#### Description

Returns a substring of the given string between indices [i, j).

#### Example

    > "hello world"[0, 5]
"""
({String}, `GetItem, *, *):
fun (s, _, v1, v2)
    {
    if (v1 is nothing)
        v1 = 0
    if (v2 is nothing)
        v2 = size(s)

    s[Int64(v1), Int64(v2)]
    };

({String}, `GetItem, *, *, *):
fun(s, _, v1, v2, v3) {
    // could implement a better, native version of this algorithm
    s.dataAsVector[v1, v2, v3].dataAsString
    };

({String}, `Member, `split):
fun (s, _, _)
    {
#Markdown("""
#### Usage

    string.split(delimiterString, maxSplitCount = -1)
    string.split()

#### Description

Return a vector of the words in the string, using `delimiterString` as the delimiter string.

If `delimiterString` is given, consecutive delimiters are not grouped together
and are deemed to delimit empty strings. The `delimiterString` argument
may consist of multiple characters. Splitting an empty
string with a specified separator returns `['']`.

If `maxSplitCount` is given, at most `maxSplitCount`
splits are done. If `maxSplitCount` is not specified or `-1`, then there is
no limit on the number of splits (all possible splits are made).

If no arguments are given, the string is split on whitespace.

#### Return Value

Returns a vector of strings.

#### Examples

    > "hello small  world".split(" ")
    > '1,,2'.split(',')
    > '1<>2<>3'.split('<>')
    > 'a b  c\td\r\ne'.split()
""")
    fun ({String} delimiterString, maxSplitCount = -1)
        {
        s`(`split, delimiterString, Int64(maxSplitCount))
        }
    () {
        [x for x in s`(`splitRegex, "\\s") if size(x) > 0]
        }
    };

({String}, `Member, `splitTuple):
fun (str, _, _)
    {
#Markdown("""
#### Usage

    string.splitTuple(delimiterString, maxSplitCount = -1)

#### Description

Return a tuple of the words in the string, using `delimiterString` as the delimiter string.

If `maxSplitCount` is given, at most `maxSplitCount` splits are done. If `maxSplitCount` is not 
specified or `-1`, then there is no limit on the number of splits (all possible splits are made).

If `delimiterString` is given, consecutive delimiters are not grouped together
and are deemed to delimit empty strings. The `delimiterString` argument
may consist of multiple characters. Splitting an empty
string with a specified separator returns `('')`.

If no arguments are given, the string is split on whitespace.

#### Examples

    > "hello small  world".splitTuple(" ")
    > '1,,2'.splitTuple(',')
    > '1<>2<>3'.splitTuple('<>')
    > 'a b  c\td\r\ne'.split()
""")
    fun ({String} delimiterString, maxSplitCount = -1)
        {
        str`(`splitToTuple, delimiterString, Int64(maxSplitCount))
        }
    () 
        {
        let vecResult = str.split();
        let tr = ();
        for val in vecResult {
            tr = tr + (val,)
            }
        tr
        }
    };

({String}, `Member, `strip):
fun(str, _, _)
    {
#Markdown("""
#### Usage

    string.strip()

#### Description

Returns a copy of `string` with all leading and trailing whitespace removed.

#### Examples

    > "  too many  spaces   ".strip()
""")
    fun ()
        {
        str `(`StripWhitespace)
        }
    };

({String}, `Member, `rstrip):
fun (str, _, _)
    {
#Markdown("""
#### Usage

    string.rstrip()

#### Description

Returns a copy of `string` with all trailing whitespace removed.

#### Examples

    > "  too many  spaces   ".rstrip()
""")
    fun ()
        {
        str `(`StripWhitespaceRight)
        }
    };

({String}, `Member, `lstrip):
fun(str, _, _)
    {
#Markdown("""
#### Usage

    string.lstrip()

#### Description

Returns a copy of `string` with all leading whitespace removed.

    > "  too many  spaces   ".lstrip()
""")
    fun()
        {
        str `(`StripWhitespaceLeft)
        }
    };

"""
#### Usage

    x in "string"

#### Description

Returns whether the given substring `x` is contained in the given string.

#### Examples

    > "hello" in "hello world!"
"""
({String}, `Operator, `in, {String}):
fun (haystack, _, _, needle)
    {
    needle`(`in, haystack)
    };

({String}, `Member, `replace):
fun(str, _, _)
    {
#Markdown("""
#### Usage

    string.replace(search, replacement)

#### Description

Returns a copy of `string` with all non-overlapping occurrences of `search` replace with `replacement`.

#### Examples

    > "hello".replace("h", "y").replace("o", "ow")
""")
    fun (search, replacement)
        {
        str `(`SearchAndReplace, search, replacement)
        }
    };

({String}, `Member, `count):
fun (str, _, _)
    {
#Markdown("""
#### Usage

    string.count(sub)

#### Description

Returns the number of non-overlapping occurrences of string `sub` within `string`.

    > "these are not the droids you are looking for".count("he")
    > "aaaaaaa".count("aaa")
""")
    fun (searchStr)
        {
        str `(`CountSubstringOccurrences, searchStr)
        }
    };

({String}, `Member, `startsWith):
fun(haystack,_,_)
    {
#Markdown("""
#### Usage

    string.startsWith(otherString)

#### Description

Returns whether `string` starts with the identical characters as the given `otherString`.

#### Examples

    > "hello world".startsWith("hello")
    > "hello world".startsWith("world")
""")
    fun(s) {
		haystack`(`clib_startsWith, s)
        }
    };

({String}, `Member, `endsWith):
fun(haystack,_,_)
    {
#Markdown("""
#### Usage

    string.endsWith(otherString)

#### Description

Returns whether `string` ends with the identical characters as the given `otherString`.

#### Examples

    > "hello world".endsWith("world")
    > "hello world".endsWith("hello")
""")
    fun(s) {
		haystack`(`clib_endsWith, s)
        }
    };

({String}, `Member, `find):
fun(haystack, _, _)
    {
#Markdown("""
#### Usage

    string.find(sub, start, end)

#### Description

Search within `string` for the left-most occurrence of `sub` occuring entirely between `start` and `end`.

If `start` or `end` is omitted, the beginning and end of `string` are used instead.  If `sub` is not
found, return `-1`.

#### Examples

    : let haystack = "a haystack"
    > haystack.find("needle")
    > haystack.find("hay")
    > haystack.find("a", 0, 4)
    > haystack.find("a", 4)
""")
    fun(needle, startPos=0, endPos=nothing)
        {
        let haystackSize = size(haystack);

        if (endPos is nothing)
            endPos = haystackSize;

		return haystack`(`FindSubstring, needle, startPos, endPos)		
        }
    };

({String}, `Member, `rfind):
fun(haystack, _, _)
    {
#Markdown("""
#### Usage

    string.rfind(sub, start, end)

#### Description

Search within `string` for the right-most occurrence of `sub` occuring entirely between `start` and `end`.

If `start` or `end` is omitted, the beginning and end of `string` are used instead.  If `sub` is not
found, return `-1`.

#### Examples

    : let haystack = "a haystack"
    > haystack.rfind("needle")
    > haystack.rfind("hay")
    > haystack.rfind("a", 0, 4)
    > haystack.rfind("a", 4)
""")
    fun (needle, startPos=0, endPos=nothing)
        {
        let haystackSize = size(haystack);

        if (endPos is nothing)
            endPos = haystackSize;

		return haystack`(`FindSubstringRight, needle, startPos, endPos)
        }
    };

({String}, `Member, `index):
fun(haystack,_,_)
    {
#Markdown("""
#### Usage

    string.index(sub, start, end)

#### Description

Search within `string` for the left-most occurrence of `sub` occuring entirely between `start` and `end`.

If `start` or `end` is omitted, the beginning and end of `string` are used instead.  If `sub` is not
found, raise an exception.

#### Examples

    : let haystack = "a haystack"
    > haystack.index("needle")
    > haystack.index("hay")
    > haystack.index("a", 0, 4)
    > haystack.index("a", 4)
""")
    fun (needle, startPos=0, endPos=nothing)
        {
        let haystackSize = size(haystack);

        if (endPos is nothing)
            endPos = haystackSize;

        let findResult = haystack.find(needle, startPos, endPos);
        if (findResult == -1)
            {
            throw "Substring not found.";
            }
        else
            {
            return findResult;
            }
        }
    };

({String}, `Member, `rindex):
fun(haystack, _, _)
    {
#Markdown("""
#### Usage

    string.rindex(sub, start, end)

#### Description

Search within `string` for the right-most occurrence of `sub` occuring entirely between `start` and `end`.

If `start` or `end` is omitted, the beginning and end of `string` are used instead.  If `sub` is not
found, raise an exception.

#### Examples

    : let haystack = "a haystack"
    > haystack.rindex("needle")
    > haystack.rindex("hay")
    > haystack.rindex("a", 0, 4)
    > haystack.rindex("a", 4)
""")
    fun(needle, startPos=0, endPos=nothing)
        {
        let haystackSize = size(haystack);

        if (endPos is nothing)
            endPos = haystackSize;

        let findResult = haystack.rfind(needle, startPos, endPos);
        if (findResult == -1)
            {
            throw "Substring not found.";
            }
        else
            {
            return findResult;
            }
        }
    };

"""
#### Usage

    "string" * n

#### Description

Repeats the given string `n` times.

#### Examples

    > "hello" * 3
"""
({String}, `Operator, `*, *):
fun (str, _, _, num)
    {
    if (num <= 0) return ""
    if (num == 1) return str
    if (num % 2 == 0)
    	{
    	let half = (str * (num/2))
    	return half+half
    	}
    return str * (num-1) + str
    };

({String}, `Operator, `<, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) < 0
    };

({String}, `Operator, `>, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) > 0
    };

({String}, `Operator, `<=, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) <= 0
    };

({String}, `Operator, `>=, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) >= 0
    };

({String}, `Operator, `==, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) == 0
    };

({String}, `Operator, `!=, {String}):
fun(a, _, _, b)
    {
    `StringLexicalCompare(a, b) != 0
    };


({String}, `Member, `reverse):
fun(str,_,_)
    {
#Markdown("""
#### Usage

    string.reverse()

#### Description

Returns a copy of `string` with the order of all characters reversed.

#### Examples

	> "abcdefghijklmnopqrstuvwxyz".reverse()
""")
    fun()
        {
        str `(`ReverseString);
        }
    };

({String}, `Member, `uppercase):
fun(str,_,_)
    {
#Markdown("""
#### Usage

    string.uppercase()

#### Description

Returns a copy of `string` in uppercase.

#### Examples

    > "RaNSoM nOTe".uppercase()
""")
    fun()
        {
        str `(`ConvertToUpperCase)
        }
    };

({String}, `Member, `lowercase):
fun(str,_,_)
    {
#Markdown("""
#### Usage

    string.lowercase()

#### Description

Returns a copy of `string` in lowercase.

#### Examples

    > "RaNSoM nOTe".lowercase()
""")
    fun()
        {
        str `(`ConvertToLowerCase)
        }
    };

({String}, `Member, `capitalize):
fun(str,_,_)
    {
#Markdown("""
#### Usage

    string.capitalize()

#### Description

Returns a copy of `string` with the first letter capitalized and the rest in lowercase.

#### Examples

    > "RaNSoM nOTe".capitalize()
""")
    fun()
        {
        str `(`CapitalizeString)
        }
    };

({String}, `Member, `swapcase):
fun(str,_,_)
    {
#Markdown("""
#### Usage

    string.swapcase()

#### Description

Returns a copy of `string` in with all lowercase characters capitalized and all uppercase ones in lowercase.

#### Examples

    > "RaNSoM nOTe".swapcase()
""")
    fun()
        {
        str `(`SwapStringCase)
        }
    };

({String}, `Member, `joinArgs):
fun (self, _ ,_)
    {
    fun (*args)
        {
        self`(`Join, *args..apply(String))
        }
    };

//TODO PERFORMANCE brax: vector string join is really slow
({String}, `Member, `join):
fun (self, _, _)
    {
#Markdown("""
#### Usage

    string.join(vector)
    string.join(*args)

#### Description

Returns a string containing all elements of the provided vector or tuple concatenated with `string` as the separator.

#### Examples

	> ", ".join([1,2,3,4])
	> "\\n".join("line 1", 2, 1.5, 'final line')
""")
    fun 
    ((*args))
        {
        self.joinArgs(*args)
        }
	(arg)
	    {
		if (`IsVector(arg))
			return self`(`JoinVec, arg.apply(String))

		if (arg is [])
		    {
			return "";
			}
		else {
		    return self.joinArgs(arg)
			}
		}
    (*args)
        {
        self.joinArgs(*args)
        }
    };

({String}, `JoinVec, {Vector}):
fun (s, _, v)
    {
    let join = fun(low, high)
        {
        if (low >= high)
            return ""
        if (low + 1 >= high)
            return String(v[low])

        let mid = (low+high)/2

        join(low,mid) + s + join(mid, high)
        };

    join(0, size(v))
    };

	//String formatting:
	(`SplitFormatString, `Call, *):
		fun (_, _, str) {
			let stringLiterals = (), formatSpecifiers = ()
			let i = 0, startOfCurrentStringLiteral = 0
			let currentStringLiterals = ()

			while (i < size(str)) {
				if (str[i] == '%'[0]) {
					//We have a format specifier.
					if (str[i + 1] == '%'[0]) {
						//Escaped '%'; tack first '%' onto the end of
						//the current string literal part.
						currentStringLiterals = currentStringLiterals
													+ (str[startOfCurrentStringLiteral, i + 1],)
						//And skip past the second '%'.
						startOfCurrentStringLiteral = i + 2
						i = i + 2
						}
					else {
						currentStringLiterals = currentStringLiterals
													+ (str[startOfCurrentStringLiteral, i],)
						stringLiterals = stringLiterals + (''.join(currentStringLiterals),)
						let (indexAfter, formatSpecifier) = `ExtractStringFormatSpecifier(str, i)
						formatSpecifiers = formatSpecifiers + (formatSpecifier,)
						currentStringLiterals = ()
						startOfCurrentStringLiteral = indexAfter
						i = indexAfter
						}
					}
				else //We're still in the middle of a string literal.
					i = i + 1
				}

			//Add the last string literal, which will be '' if the format
			//string ended with a format specifier.
			currentStringLiterals = currentStringLiterals + (str[startOfCurrentStringLiteral, i],)
			stringLiterals = stringLiterals + (''.join(currentStringLiterals),);

			(stringLiterals, formatSpecifiers)
			};

	(`ExtractStringFormatSpecifier, `Call, ... *):
		fun
			(_, _, str) { `ExtractStringFormatSpecifier(str, 0) }
			(_, _, str, startIndex) {
				if (startIndex >= size(str))
					throw "Empty string passed to `ExtractStringFormatSpecifier."
				if (str[startIndex] != '%'[0])
					throw "Malformed string format specifier: first character is not '%'."
				if (str[startIndex + 1] == '%'[0])
					throw "Internal error: '%%' escapes should not make it to `ExtractStringFormatSpecifier."

				let i = startIndex + 1 //Advance past opening '%'.
				let keyStr = '',
				    flagsStr = '',
				    widthStr = '',
				    precisionStr = '',
				    typeStr = '';

				if (i >= size(str))
					throw "Malformed string format specifier: unexpected end-of-string."

				//First, look for a key.
				if (str[i] == '<'[0]) {
					keyStr = '<'
					i = i + 1
					}
				else if (str[i] == '('[0]) {
					let startOfKey = i
					while (str[i] != ')'[0])
						if (i >= size(str))
							throw "Malformed string format specifier: ')' expected."
						else
							i = i + 1
					i = i + 1 //Advance past ')'.
					keyStr = str[startOfKey, i] //e.g., '(blah)'
					}
				else if (str[i] == '['[0]) {
					let startOfKey = i
					while (str[i] != ']'[0])
						if (i >= size(str))
							throw "Malformed string format specifier: ']' expected."
						else
							i = i + 1
					i = i + 1 //Advance past ']'.
					keyStr = str[startOfKey, i] //e.g., '[123]'
					}

				//Then look for conversion flag(s).
				let flagsStart = i
				while (str[i, i + 1] in '#0- +')
					i = i + 1
				flagsStr = str[flagsStart, i]

				//Next, check for a width descriptor.
				if (str[i] == '*'[0]) {
					throw "Malformed string format specifier: '*' not supported."
					}
				else {
					let startOfWidth = i
					while ('0'[0] <= str[i] and str[i] <= '9'[0])
						i = i + 1
					widthStr = str[startOfWidth, i]
					}

				//Now, the precision.
				if (str[i] == '.'[0]) {
					if (str[i + 1] == '*'[0]) {
						throw "Malformed string format specifier: '*' not supported."
						precisionStr = '.*'
						i = i + 1
						}
					else {
						let startOfPrecision = i //Be sure to include '.'

						i = i + 1 //Advance past '.'.

						while ('0'[0] <= str[i] and str[i] <= '9'[0])
							i = i + 1

						if (i == startOfPrecision + 1) {
							//We failed to consume any digits.
							throw "Malformed string format specifier: precision expected after '.'."
							}

						precisionStr = str[startOfPrecision, i]
						}
					}

				//Finally, the conversion type.
				if (i >= size(str))
					throw "Malformed string format specifier: conversion type expected."
				typeStr = str[i, i + 1]
				i = i + 1

				let indexAfter = i;

				(
					indexAfter,
					(
						keyStr:       keyStr,
						flagsStr:     flagsStr,
						widthStr:     widthStr,
						precisionStr: precisionStr,
						typeStr:      typeStr
					)
				)
				}
			;

	(`KeyForParsedStringFormatSpecifier, `Call, *):
		fun (_, _, formatSpecifier) {
			if (formatSpecifier.keyStr is '')
				#Positional()
			else
				match (formatSpecifier.keyStr[, 1]) with
					('(') { #ByName(formatSpecifier.keyStr[1, -1]) }         //Chop off '(' and ')'.
					('[') { #ByIndex(Int64(formatSpecifier.keyStr[1, -1])) } //Chop off '[' and ']'.
					('<') { #Repeat() }
					(k) {
						throw "Malformed string format specifier: invalid key '"
									+ formatSpecifier.keyStr + "'."
						}
			};

	(`TypeConversionForParsedStringFormatSpecifier, `Call, *):
		fun (_, _, formatSpecifier) {
			match (formatSpecifier.typeStr) with
				('d' or 'i' or 'x' or 'X')
					{ Int64 }
				('u')
					{ UInt64 }
				('e' or 'E' or 'f' or 'g' or 'G')
					{ Float64 }
				('c')
					{ fun ({String} str) { str.c } (x) { UInt8 } }
				('?')
					{ Bool }
				('s')
					{ String }
				('r')
					{ `ParsableRepresentation }
				(t)
					{
					throw "Malformed string format specifier: invalid conversion type '" + t + "'."
					}
			};

	(`StringizerForParsedStringFormatSpecifier, `Call, *):
		fun (_, _, formatSpecifier) {
			match (formatSpecifier.typeStr) with
				('?') { fun (bool) { `formatWidthAndPrecision(String(bool), formatSpecifier) } }
				(_) {
					let boostTypeString = match (formatSpecifier.typeStr) with
						('r') { 's' }
						('?') { 'b' }
						(t)   { t }

					let boostSpecifierString = ''.join((
						'%',
						formatSpecifier.flagsStr,
						formatSpecifier.widthStr,
						formatSpecifier.precisionStr,
						boostTypeString
						))

					`FormatStringizerFromBoostFormatSpecifierString(boostSpecifierString)
					}
			};
	//as noted in FORA-640, this axiom is dangerous
	(`FormatStringizerFromBoostFormatSpecifierString, `Call, *):
		fun (_, _, boostSpecifierString) {
			fun
				({Int64}   i) { `SprintfInt64 (boostSpecifierString, i) }
				({UInt64}  u) { `SprintfUInt64(boostSpecifierString, u) }
				({Float64} f) { `SprintfDouble(boostSpecifierString, f) }
				({UInt8}   c) { `SprintfChar  (boostSpecifierString, c) }
				({String}  s) { `SprintfString(boostSpecifierString, s) }
			};
	(`formatWidthAndPrecision, `Call, *, *):
		fun (_, _, unmodified, formatSpecifier) {
			let choppedLength =
				if (formatSpecifier.precisionStr is '')
					size(unmodified)
				else
					size(unmodified) <<< UInt64(formatSpecifier.precisionStr[1, ]) //chop off initial '.'

			let chopped = unmodified[, choppedLength]

			let padCount =
				if (formatSpecifier.widthStr is '')
					0
				else
					(size(chopped) >>> UInt64(formatSpecifier.widthStr)) - size(chopped)

			let leftAlign = '-' in formatSpecifier.flagsStr
			let padChar =
				if ('0' in formatSpecifier.flagsStr and not leftAlign)
					'0'
				else
					' '

			if (leftAlign)
				chopped + padChar * padCount
			else
				padChar * padCount + chopped
			};

	(`ReorderStringFormatArgsByKeys, `Call, *, *):
		fun (_, _, args, keys) {
			let res = ()
			let i = -1
			for key in keys {
				res = res + (match (key) with
					(#Positional()) { i = i + 1; args[i] }
					(#ByName(name)) { args`(`Member, `StringToSymbol(name)) }
					(#ByIndex(ind)) { args[ind] }
					(#Repeat()) {
						if (i is -1)
							throw "Malformed format string: first specifier cannot have key '<'."
						args[i]
						}
					,)
				}
			res
			};

	(`InterleaveFormattedStringComponents, `Call, *, *):
		fun (_, _, literalStringsTuple, formattedStringsTuple) {
            let literalStringsIterator = literalStringsTuple `(`Iter)
			let formattedStringsIterator = formattedStringsTuple`(`Iter)

			let res = ()

			while (formattedStringsIterator`(`Next, nothing) is not nothing)
				res = res + (pull literalStringsIterator, pull formattedStringsIterator)

			//Don't forget the last literal string.
			res = res + (pull literalStringsIterator,)

			res
			};

({String}, `Member, `format):
fun (str, _, _)
    {
#Markdown("""
#### Usage

    string.format(*args)

#### Description

Returns a copy of `string` with the values of `args` substituted for parameters.

#### Examples

	> "Hello %s, welcome to %s.".format("User", "FORA")
	: let pattern = "The result is '%10d'"
	> pattern.format(1+2)
	> pattern.format(10*20)
""")
    fun (*args)
        {
        let (literalStringsTuple, formatSpecifiers) = `SplitFormatString(str)

        let keys = formatSpecifiers..apply(`KeyForParsedStringFormatSpecifier)
        let typeConversions =
                formatSpecifiers..apply(`TypeConversionForParsedStringFormatSpecifier)
        let stringizers = formatSpecifiers..apply(`StringizerForParsedStringFormatSpecifier)

        let reorderedArgs = `ReorderStringFormatArgsByKeys(args, keys)

        let convertedArgs = typeConversions(reorderedArgs)
        let formattedArgs = stringizers(convertedArgs)

        let interleaved =
                `InterleaveFormattedStringComponents(literalStringsTuple, formattedArgs)

        ''.join(interleaved)
        }
    };

//STRINGization
(String, `Call, {String}):
fun(_, _, x) { x };

(String, `Call, jovsbelow {Class(*)}):
fun(_, _, x)
    {
    /*let meta = `ExtractMetadata(x);*/

    let name = `ExtractClassTypeName(x);

    /*if (meta is nothing)                                     */
    /*    return name + ": " + `ParsableRepresentation(x);     */

    /*let userdata =                                           */
    /*    match (meta) with                                    */
    /*        ((user: nothing, ...)) { "" }                    */
    /*        ((user: u, ...)) { "\n\nmetadata: " + String(u) }*/
    /*        (_) { "" }                                       */
    /*        ;                                                */

    /*name + userdata                                          */
    name
    };

"""
#### Usage

    String(vector)

#### Description

Return a stringified representation of the given vector.

This function truncates the stringified vector at 1024 characters.

#### Examples

    : let v = Vector.range(100.0);
    > String(v)

"""
(String, `Call, {Vector}):
fun(_, _, vec)
    {
    if (vec is [])
        return "[]";

    let getElts = fun() {
        let used = 0;
        let elts = [];

        for v in vec {
            if (used > 1024) {
                return elts :: "...";
                }

            let strRep = String(v);

            used = used + size(strRep)
            elts = elts :: strRep
            }
        return elts
        };

    "[" + ", ".join(getElts()) + "]"
    };

"""
#### Usage

    String(mutableVector)

#### Description

Return a string representing the given MutableVector.

This call will truncate the stringified vector at 1024 characters.

#### Example

    : let m = MutableVector(Float64).create(10, 5.0);
    > String(m)

"""
(String, `Call, {MutableVector}):
fun(_, _, vec)
    {
    if (size(vec) == 0)
        return "MutableVector(" + String(vec.elementType) + ")([])";

    let getElts = fun() {
        let used = 0;
        let elts = [];

        let ix = 0;
        while (ix < size(vec)) {
            let v = vec[ix];
            ix = ix + 1;

            if (used > 1024) {
                return elts :: "...";
                }

            let strRep = String(v);

            used = used + size(strRep)
            elts = elts :: strRep

            }
        return elts
        };

    "MutableVector(" + String(vec.elementType) + ")([" + ", ".join(getElts()) + "])"
    };

"""
#### Usage

    String(object)

#### Description

Returns the given object converted to a string.

This operates on objects, classes, and instances of classes by calling the "convert" operations in 
their definitions.

#### Examples

Classes and class instances. Note the use of "convert" and the included type.

    : let c = class {
          member x;
          static convert(String) {
              "the class"
              };
          convert(String) {
              x + " is the word";
              };
          };
    > String(c)
    : let o = c("hello");
    > String(o)

"""
(String, `Call, {Class(*)}):
fun(_, _, x)
    {
    x `( `Convert, String)
    };

(String, `Call, *):
fun(_, _, x)
    {
    `ParsableRepresentation(x)
    };

(String, `Call, *, {Dictionary}):
fun(_, _, x, d)
    {
    `ParsableRepresentation(x, d)
    };


// -----------------------------------------------------------------------------------------------
// Symbols

({Symbol}, `Convert, String):
	fun(s, _, _)
		{
		`SymbolToStringNoBacktick(s)
		};
({Symbol}, `Operator, `<, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) < 0
        };
({Symbol}, `Operator, `>, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) > 0
        };
({Symbol}, `Operator, `<=, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) <= 0
        };
({Symbol}, `Operator, `>=, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) >= 0
        };
({Symbol}, `Operator, `==, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) == 0
        };
({Symbol}, `Operator, `!=, {Symbol}):
    fun(a, _, _, b)
        {
        `SymbolCompare(a, b) != 0
        };


// -----------------------------------------------------------------------------------------------
// nothing

(Nothing, `Call, ... *): fun(_,_,*args) { nothing };
(nothing, `Call, ... *): fun(_,_,*args) { nothing };
(nothing, `Operator, `+, *): fun(_,_,_,other) { other };
({Integer}, `Operator, `+, nothing): fun(x,_,_,_) { x };
({Float}, `Operator, `+, nothing): fun(x,_,_,_) { x };

// -----------------------------------------------------------------------------------------------

({Integer}, `LeftOperator, `+): fun(x,_,_) { x };
({Float}, `LeftOperator, `+): fun(x,_,_) { x };

// -----------------------------------------------------------------------------------------------

(`ShortRepresentation, `Call, {Class(*)}):
	fun(_, _, x) {
		String(`TypeJOV(x))
		}
		;
(`ShortRepresentation, `Call, (... *)):
	fun(_, _, x) {
		"(" + ", ".joinArgs(*x..apply(`ShortRepresentation)) + ")"
		}
		;
(`ShortRepresentation, `Call, *):
	fun(_, _, x) { `ParsableRepresentation(x) }
		;


// -----------------------------------------------------------------------------------------------

(``BadApply, *, `Operator, *, *):
	fun(_, lhs, _, op, rhs) {
		rhs `( `ReverseOperator, op, lhs)
		}
		;

(``BadApply, *, `RightOperator, *):
	fun(_, lhs, _, op) {
		throw `Exception`().InvalidRightOperator(op, lhs)
		};

(``BadApply, *, `LeftOperator, *):
	fun(_, lhs, _, op) {
		throw `Exception`().InvalidLeftOperator(op, lhs)
		};

//by default, == and != are 'is'
(``BadApply, *, `ReverseOperator, `==, *):
	fun(_, rhs, _, _, lhs) {
		return lhs is rhs
		};
(``BadApply, *, `ReverseOperator, `!=, *):
	fun(_, rhs, _, _, lhs) {
		return not (rhs == lhs)
		};
(``BadApply, *, `ReverseOperator, *, *):
	fun(_, rhs, _, op, lhs) {
		throw `Exception`().InvalidBinaryOperator(op, lhs, rhs)
		}
		;
(``BadApply, {Class(*)}, `MatchFilter, *):
	fun(_, _, _, _) { nothing }
	;

(``BadApply, {Class(*)}, `Filter, *):
	fun(_, _, _, _) { nothing }
	;

(``BadApply, *, `Iter):
	fun(_, arg, _) { throw `Exception`().InvalidIterator(arg) }
	;

//default conversion to tuple
(``BadApply, *, `Convert, jovsbelow (... *)):
	fun (_, args, _, s) {
		try {
			s..apply(fun(z,args){z(args)}, args)
			}
		catch (...) 
			{
			throw `Exception`().InvalidConversion(args, s)			
			}
		}
		;

(``BadApply, *, `Convert, String):
	fun(_, x, _, t) {
		`ShortRepresentation(x)
		}
		;

(``BadApply, *, `Convert, *):
	fun(_, x, _, t) {
		throw `Exception`().InvalidConversion(x, t)
		}
		;

(``BadApply, *, `Member, *):
	fun(_, x, _, m) {
		throw `Exception`().InvalidMemberAccess(x, m)
		}
		;

(``BadApply, *, `Call, ... *):
	fun(_, x, _, *args) {
		throw `Exception`().InvalidCall(x, args)
		}
		;
(``BadApply, ... *):
	fun(_, *args) {
		throw `Exception`().InvalidApply(args)
		}
		;
(``BadIteratorArgument, *):
	fun(_, arg) {
		throw `Exception`().InvalidIterator(arg)
		}
		;

(``EmptyIterator): 
    fun(_) {
        throw `Exception`()(
            "can't call `pull` on the empty iterator (ie, the value `nothing`)"
            );
        }
        ;

//by default, nothing matches
(*, `MatchFilter, *):
	fun(x, _, arg) {
		nothing
		};

(*, `Filter, *):
	fun(x, _, arg) {
		nothing
		};

(`Match, *, *):
	fun(_, value, tag) {
		let result = value`(`MatchFilter, tag);

		if (result is not nothing)
			return result

		return tag `(`Filter, value)
		};

(`BadPatternMatch, *):
	fun(_, toMatch) {
		throw `Exception`().InvalidPatternMatch(toMatch)
		};


//END MATCHING

//METADATA
    // For builtin types, we want to access the module
    (`ExtractMetadataWithBuiltin, `Call, *):
        fun(_,_,t) { (kind:`builtin,
            user: fun (builtin) {
                let type =
                match (`TypeJOV(t)) with
                    (JOV) { t }
                    (...) { `TypeJOV(t) };

                let typeJovAsString = String(type);
                if (typeJovAsString[0, 6] == "Vector")
                    typeJovAsString = "Vector"
                else if (typeJovAsString[0, 3] == "Int")
                    typeJovAsString = "Integer"
                else if (typeJovAsString[0, 5] == "Float")
                    typeJovAsString = "Float"

                let moduleSymbol = Symbol(typeJovAsString.lowercase());
                let referencesNames = `ExtractMemberNames(builtin.references);

                if (moduleSymbol in referencesNames)
                    builtin.references.(moduleSymbol)
                else
                    nothing
                }
            )
        };

	//extract user data for a class type
	(`ExtractMetadata, `Call, jovsbelow {Class(*)}):
		fun(_,_,c) {
			`ExtractClassTypeMetadata(c)
			}
			;
	//extract user data for a class type
	(`ExtractMetadata, `Call, {Class(*)}):
		fun(_,_,c) {
			`ExtractClassTypeMetadata(`TypeJOV(c))
			}
			;
	//data for Nothing
	(`ExtractMetadata, `Call, Nothing): fun(_,_,t) { (kind: `builtin, user: "Nothing\n" +
			"'nothing' is the untyped unit value in FORA.  nothing has type Nothing, and\n\n" +
			"\tnothing + x is x\n\n" +
			"for all x.	 We often use 'nothing' as the initial value for sum operations, or\n" +
			"to indicate an empty state.") };
	//tuples
	(`ExtractMetadata, `Call, jovof (... *) ):
		fun(_,_,t) {
			(kind: `builtin,
			 user: "A tuple with " + String(size(t)) + " elements.\n\n" +
				"More on tuples will go here"
			)
		};
	(`ExtractMetadata, `Call, Vector ):
		fun(_,_,t) {
			(kind: `builtin,
			 user: String(t) + "\n\n" +
				"More on vectors to go here"
			)
		};
	(`ExtractMetadata, `Call, String): fun(_,_,t) { (kind: `builtin,
		user: "String, the type of all strings.\n\n" +
			"FORA strings are collections of characters.\n\n" +
			"More on strings here.\n")
		};
	(`ExtractMetadata, `Call, Symbol): fun(_,_,t) { (kind: `builtin,
		user: "Symbol, the type of symbols introduced with the '`' character.\n\n" +
			"FORA Symbols are collections of alphanumeric characters and operators\n\n" +
			"More on Symbols here.\n")
		};
	(`ExtractMetadata, `Call, Tag): fun(_,_,t) { (kind: `builtin,
		user: "Tag, the type of tags introduced with the '#' character.\n\n" +
			"FORA Tags are collections of alphanumeric characters and operators\n\n" +
			"More on Tags here.\n")
		};
	(`ExtractMetadata, `Call, Int8): fun(_,_,t)	  { (kind: `builtin, user: "Int8, a signed 8 bit integer.") };
	(`ExtractMetadata, `Call, Int16): fun(_,_,t)  { (kind: `builtin, user: "Int16, a signed 16 bit integer.") };
	(`ExtractMetadata, `Call, Int32): fun(_,_,t)  { (kind: `builtin, user: "Int32, a signed 32 bit integer.") };
	(`ExtractMetadata, `Call, Int64): fun(_,_,t)  { (kind: `builtin, user: "Int64, a signed 64 bit integer.") };
	(`ExtractMetadata, `Call, UInt8): fun(_,_,t)  { (kind: `builtin, user: "UInt8, an unsigned 8 bit integer.") };
	(`ExtractMetadata, `Call, UInt16): fun(_,_,t) { (kind: `builtin, user: "UInt16, an unsigned 16 bit integer.") };
	(`ExtractMetadata, `Call, UInt32): fun(_,_,t) { (kind: `builtin, user: "UInt32, an unsigned 32 bit integer.") };
	(`ExtractMetadata, `Call, UInt64): fun(_,_,t) { (kind: `builtin, user: "UInt64, an unsigned 64 bit integer.") };
	(`ExtractMetadata, `Call, Bool):   fun(_,_,t) { (kind: `builtin, user: "Bool, a boolean. Values are either 'true' or 'false'.") };
	(`ExtractMetadata, `Call, Float32): fun(_,_,t)	{ (kind: `builtin, user: "Float32, a signed 32 bit floating-point number.") };
	(`ExtractMetadata, `Call, Float64): fun(_,_,t)	{ (kind: `builtin, user: "Float64, a signed 64 bit floating-point number.") };

	//default for types we didn't get to
	(`ExtractMetadata, `Call, {JOV}): fun(_,_,t) { (kind: `builtin, user: String(t)) };

	//by default, if we don't match something specific, resolve
	//to the metadata for the class
	(`ExtractMetadata, `Call, *):
		fun(_,_,c) {
			match (`ExtractMetadata(`TypeJOV(c))) with
				((user: u, *meta)) {
					(user: "Instance of " + u, *meta)
					}
			}
			;
	(`ExtractMemberNames, `Call, {Class(*)}):
		fun(_,_,c) { `ExtractMemberNames(`TypeJOV(c)) }
		;
//END METADATA

((...*), `Member2, `unnamedCopy): 
#Markdown(
"""#### Usage

    tuple..unnamedCopy

#### Description

Return an unnamed copy of a tuple.

#### Examples

    (a: 1, b: 2, 3)..unnamedCopy

""")
fun(t,_,_) {
	if (size(t))
		(t[0],) + t[1,]..unnamedCopy
	else
		()
	};
(jovof (... *), `GetItem, *):
	fun(t,_,x) {
		t[Int64(x)]
		};
(jovof (... *), `GetItem, *, *):
	fun(t,_,x,x2) {
		t[if (x is nothing) 0 else Int64(x),
		  if (x2 is nothing) Int64(size(t)) else Int64(x2)]
		};
(jovof (... *), `Call):		fun(t,_) { t..apply(fun(ty){ty()}) };

((... *), `Operator, `+, (... *)): fun (s1, _, _, s2) { (*s1, *s2) };

((... *), `GetItem, {Symbol}): fun(t,_,x) { t.(x) };

((... *), `GetItem, *): fun(t,_,x) { t[Int64(x)] };

((... *), `GetItem, *, *):
	fun(t,_,x,x2) {
		t[if (x is nothing) 0 else Int64(x),
		  if (x2 is nothing) Int64(size(t)) else Int64(x2)]
		}
		;

((... *), `Operator, `*, *):
fun(tup, _, _, num)
    {
	let tr = ();
	let ix = 0;

	if (num <= 0)
		return tr;

	while (ix < num)
	    {
		tr = tr + tup
		ix = ix + 1
	    }
	tr
    };

((... *), `Operator, `==, (... *)):
	fun(t1, _, _, t2) {
		if (t1 is () and t2 is ())
			return true;
		if (t1 is () or t2 is ())
			return false;
		if (t1[0] == t2[0])
			{
			t1[1,] == t2[1,]
			}
			else
			false
		}
		;
((... *), `Operator, `!=, (... *)):
	fun(t1, _, _, t2) {
		if (t1 is () and t2 is ())
			return false;
		if (t1 is () or t2 is ())
			return true;
		if (t1[0] != t2[0])
			return true;

		t1[1,] != t2[1,]
		}
		;
((... *), `Operator, `>, (... *)):
    fun(t1, _, _, t2) {
		if (t1 is () and t2 is ())
			return false;
        if (t1 is ())
            return false
        if (t2 is ())
            return true
        if (t1[0] == t2[0])
            return t1[1,] > t2[1,]
        return t1[0] > t2[0]
    }
    ;
((... *), `Operator, `<, (... *)):
    fun(t1, _, _, t2) {
		if (t1 is () and t2 is ())
			return false;
        if (t1 is ())
            return true
        if (t2 is ())
            return false
        if (t1[0] == t2[0])
            return t1[1,] < t2[1,]
        return t1[0] < t2[0]
    }
    ;
((... *), `Operator, `<=, (... *)):
    fun(t1, _, _, t2) {
        !(t1 > t2)
    }
    ;
((... *), `Operator, `>=, (... *)):
    fun(t1, _, _, t2) {
        !(t1 < t2)
    }
    ;

((... *), `Member2, `apply ):
	fun(tup,_,_) {
		let tupleApplyFun =
#Markdown(
"""
#### Usage 
 
    tup..apply(applyFun)
    tup1..apply(applyFun, tup2, tup3, ...)

#### Description

The first case produces a new tuple of the same size as `tup` whose 
`ix`th entry is `applyFun(tup[ix])`.

The second case produces a new tuple the same size as `tup` whose 
`ix`th entry is `applyFun(tup1[ix], tup2[ix], tup3[ix], ...)`

#### Examples

    (1,2,3)..apply( { _ ** 2.0 } ) == (1.0,4.0,9.0)
    (1,2,3)..apply(fun(x,y) { x + y }, (4,5,6)) == (5,7,9)
    (1,2)..apply(fun(x,y,z) { (x,y,z) }, (3,4,5), (6,7)) == ((1,3,6),(2,4,7))
    (1,2)..apply(fun(x,y) { ((y): x) }, (`a, `b)) == ((a: 1), (b: 2))
 
"""
)
			fun(f, *args) {
				``TupleApplyFun(
					`TypeJOV(tup),
					`TypeJOV(args)
					)(f, tup, *args)
				};
		tupleApplyFun
		}
	;

((... *), `Member2, `applyWithIndex):
	fun(tup,_,_) {
		let tupleApplyWithIndexFun =
#Markdown(
"""
#### Usage 
 
    tup..applyWithIndex(applyFun)
    tup1..applyWithIndex(applyFun, tup2, tup3, ...)

#### Description

The first case produces a new tuple of the same size as `tup` whose 
`ix`th entry is `applyFun(tup[ix], ix)`.

The second case produces a new tuple the same size as `tup` whose 
`ix`th entry is `applyFun(tup1[ix], tup2[ix], tup3[ix], ... , ix)`

#### Examples

    let t = (1,2,3);
    let f = fun(elt, ix) { (elt: elt, ix: ix) };

Then

    t..applyWithIndex(f) == ((elt:1, ix:0), (elt:2, ix:1), (elt:3, ix:2))

Or consider

    let t1 = (1,2,3);
    let t2 = (4,5,6,7)

Then

    t1..applyWithIndex(f, t2) == ((elt1:1, elt2:4, ix:0), 
                                  (elt1:2, elt2:5, ix:1), 
                                  (elt1:3, elt2:6, ix:2))

 
"""
)
			fun(f, *args) {
				``TupleApplyWithIndexFun(
					`TypeJOV(tup),
					`TypeJOV(args)
					)(f, tup, *args)
				};
		tupleApplyWithIndexFun
		}
	;


((... *), `Member2, `names ):
#Markdown("""
#### Usage

    tup..names

#### Description

Return the names of a tuple.

#### Examples

    (a: 1, 2, b: 3)..names

""")
	fun(self,_,_) {
		`TypeJOV(self)..names
		}
	;

((... *), `Operator, `in, *):
	fun(tup, _, _, x) {
		while (tup is not ())
			{
			if (tup[0] is x)
				return true
			tup = tup[1,]
			}
		return false
		}
	;

((... *), `Call, *):
	fun(self, _, arg) {
		self..apply(fun(f,a) { f(a) }, arg)
		}
	;

(jovsbelow (... *), `Member2, `apply):
	fun(self,_,_) {
		fun(f, *args) { 
			``TupleApplyFun(
				self, 
				`TypeJOV(args)
				)(f, self, *args) 
			} 
		}
	;

((... *), `Iter):
	fun(t, _) {
		let tup = t
		while (tup is not ()) {
			yield tup[0]
			tup = tup[1,]
			}
		};

(jovsbelow (... *), `Member2, `range):
    fun(_, _, _) {
        fun(n) {
            `createTupleRange(n)
            }
        }
    ;

(`size, `Call, {Class(*)}):
	fun(_,_,t) { t `(`size) };

(`Float, `Call, *): fun(x,_,t) { x(UInt64(t)) };

(`Integer, `Call, *): fun(x,_,t) { x(UInt64(t), true) };
(`Integer, `Call, *, *): fun(x,_,t,s) { x(UInt64(t), Bool(s)) };

(`ProcessToVector, `Call, ... *):
	fun(_, _, p) {
		let res = [];

		for x in p {
			res = res :: x;
			};

		res
		}
		;

//MUTABLE VECTOR
(jovsbelow {MutableVector(jovsbelow *)}, `Member, `create):
	fun(vectorJov, _, _) {
		let createMutableVector =
            #Markdown(
"""#### Usage

    mutableVectorType.create(count, defaultValue)

#### Description

Create a `MutableVector` of type `mutableVectorType` having `count` values,
all with default value `defaultValue`.

#### Examples

    MutableVector(Int64).create(10, 0) // creates a MutableVector of Int64s
    MutableVector(Float64).create(10, 0.0) // creates a MutableVector of Float64's
    MutableVector.create(10, nothing) // creates a MutableVector of anything

""")
			fun (count, defaultValue) {
				`CreateMutableVector(vectorJov, UInt64(count), defaultValue)
				}
				() {
				`CreateMutableVector(vectorJov)
				}
			;
		createMutableVector
		};
({MutableVector}, `Member, `resize):
	fun(v,_,_) {
		let resizeMutableVector =
            #Markdown(
"""#### Usage

    mutableVector.resize(newSize, defaultValue)

#### Description

Resize a `MutableVector` with a default value on the newly created values.

*NOTE*: this is a _mutating_ operation on the `MutableVector`.

#### Examples

    let m = MutableVector(Int64).create(10, 0);
    m.resize(15, 1) // m really is modified here

""")
			fun (count, defaultValue) {
				v`(`Resize, UInt64(count), defaultValue)
				}
			;
		resizeMutableVector
		};

({MutableVector}, `GetItem, *):
	fun(v,_,ix) {
		v[Int64(ix)]
		};

({MutableVector}, `SetItem, *, *):
	fun(v,_,ix, val) {
		v[Int64(ix)] = val
		};

({MutableVector}, `Iter):
	fun(v, _) {
		let ix = 0;
		while (ix < size(v)) {
			yield v[ix]
			ix = ix + 1
			}
		}
		;

({Vector}, `Operator, `+, {Vector}):
    fun(v1,_,_,v2) {
        if (`stride(v1) != 1)
        	v1 = [x for x in v1]
        
        if (`stride(v2) != 1)
        	v2 = [x for x in v2]

        let v1Concat = v1 `( `appropriateForConcatenation )
        let v2Concat = v2 `( `appropriateForConcatenation )

        v1Concat `( `concatenate, v2Concat )
        }
        ;

({Vector}, `GetItem, *):
	fun(v,_,ix) {
		v[Int64(ix)]
		}
		;

({Vector}, `Operator, `::, *):
    fun(v,_,_,x) {
        v `( `append, x )
        }
        ;


({Vector}, `GetItem, *, *):
	fun(v,_,ix1, ix2) {
		if (ix1 is nothing)
			ix1 = 0;

		if (ix2 is nothing)
			ix2 = size(v);

		v[Int64(ix1), Int64(ix2)]
		}
		;

({Vector}, `GetItem, *,*,*):
	fun(v,_,ix1, ix2, ix3) {
        if (ix3 is nothing)
            ix3 = 1

		ix3 = Int64(ix3)

		if (ix1 is nothing)
			ix1 = (if (ix3 > 0) 0 else size(v) - 1)

		if (ix2 is nothing)
			ix2 = (if (ix3 < 0) -size(v)-1 else size(v))

		return v[Int64(ix1), Int64(ix2), Int64(ix3)]
		};

({Vector}, `GetItemDeepcopied, *,*,*):
	fun(v,_,ix1, ix2, ix3) {
		return [x for x in v[Int64(ix1), Int64(ix2), Int64(ix3)]]
		};

(`IsVector, `Call, {Vector}):
    fun(_, _, _) { true };
(`IsVector, `Call, *):
    fun(_, _, _) { false };

(Vector, `Member, `range):
	fun(_,_,_) {
	let vectorRange = 
#Markdown(
"""
#### Usage

1. `Vector.range((low, high))`
2. `Vector.range((low, high), f)`
3. `Vector.range(ct)`
4. `Vector.range(ct, f)`

#### Description

Return a range of values, built out of an arithmetic progression.

Case 1. Returns the arithmetic progression `[Int64(low), Int64(low) + 1, ... , Int64(high) - 1]`. 
For example:

    Vector.range((3, 6)) == [3, 4, 5];
	Vector.range((6, 3)) == [];
	Vector.range((3.0, 6)) == [3, 4, 5];
	Vector.range((3, 6.0)) == [3, 4, 5];
	Vector.range((3.5, 6)) == [3, 4, 5];

Case 2. is equivalent to `Vector.range((low, high)).apply(f)`.

    Vector.range((0, 3), fun(elt) { 2 * elt }) == [0, 2, 4];
 
Case 3. is equivalent to ``Vector.range((0, ct))``. For example:

    Vector.range(5) == [0, 1, 2, 3, 4];
    Vector.range(5.0) == [0, 1, 2, 3, 4];

Case 4. is equivalent to ``Vector.range((0, ct) f)``. For example

    Vector.range(4, Float64) = [0.0, 1.0, 2.0, 3.0];
    Vector.range(4.0, fun(x) { x ** 2.0 }) == [0.0, 1.0, 4.0, 9.0];
    Vector.range(4, fun(x) { Vector.range(x) }) == [[], [0], [0, 1], [0, 1, 2]];

""")
	fun ((low, high), f = { _ }, filter = { true })
			{
			low = Int64(low)
			high = Int64(high)
			
			if (low >= high)
				return []
			if (low + 1 >= high)
				return (if(filter(low)) [f(low)] else []);

			if (low + 1000000 < high)
				{
				let mid = Int64((low + high) / 2);

				return vectorRange((low, mid), f, filter) + 
							vectorRange((mid, high), f, filter)
				}

			let res = []
			while (low<high) {
				let should_keep = filter(low);

				if (should_keep) {
					let f_x = f(low);

					if (`split) {
						let splitter = fun() {
							__without_stacktrace_augmentation {
								let mid = Int64((low+1+high)/2);

								return vectorRange((low+1,mid),f,filter) + vectorRange((mid,high),f,filter);
								}
							}

						__without_stacktrace_augmentation {
							let splitRes = splitter();

							return res :: f_x + splitRes
							}
						}

					res = res :: f_x
					}

				low = low + 1
				}
				
			return res
			}
		(ct)
			{
			return vectorRange((0, ct))
			}
		(ct, f, filter= { true })
			{
			return vectorRange((0, ct), f, filter)
			}

		return vectorRange;
		}
	;

(Vector, `Member, `uniform):
	fun (_,_,_) {
#Markdown(
"""#### Usage

    Vector.uniform(count, value)

#### Description

Returns a vector with `count` elements all having value `value`.

#### Examples

    Vector.uniform(100, 0.0)

""")
		fun(count, value) {
			let v = [];
			while (size(v) < count)
				v = v :: value
			return v
			}
		};

({Vector}, `Operator, `==, {Vector}):
	fun(v1, _,_,v2) {
		if (size(v1) != size(v2))
			return false;

		let ix = 0;
		while (ix < size(v1)) {
			if (v1[ix] != v2[ix])
				return false;
			ix = ix + 1
			}

		return true;
		};

({MutableVector}, `Operator, `==, {MutableVector}):
	fun(v1, _,_,v2) {
		if (size(v1) != size(v2))
			return false;

		let ix = 0;
		while (ix < size(v1)) {
			if (v1[ix] != v2[ix])
				return false;
			ix = ix + 1
			}

		return true;
		};

({Vector}, `Operator, `in, *):
	fun(v, _, _, x) {
		let ix = 0
		while (ix < size(v))
			{
			if (v[ix] is x)
				return true

			ix = ix + 1
			}
		return false
		}
	;

({Vector}, `Member, `sum):
	fun(self, _, _)
		{
		let vectorSum = 
#Markdown(
"""#### Usage

	v.sum(
		transform = fun(x){x},
		add = fun(x, y) { x + y }
		)

#### Description

Sum the elements of a vector `v` (possibly applying a transformation first).

`transform`: a function to be applied to each element of the vector.
`add`: a function that adds a cumulative result and a transformed vector element.

#### Examples

    [0, 1, 2, 3].sum() == 6;
    [[0, 1], [2, 3, 4], [5]] == [0, 1, 2, 3, 4, 5];
	[0, 1, 2, 3].sum(fun(x) { x ** 2 }) == 0 ** 2 + 1 ** 2 + 2 ** 3 + 3 ** 4;
    [1, 2, 3, 4].sum(identity, fun(x, y) { x * y }, fun(x, y) { x * y }) == 1 * 2 * 3 * 4;
	

""")
		fun(	transform = fun(x) { x },
				add = fun(x,y) { x + y },
				merge = add,
				low = 0,
				high = size(self),
				depth = 0
				)
			{
			if (low >= high)
				return nothing

			if (low+1 >= high)
				return add(nothing, transform(self[low]))

			if (depth > 10)
				{
				let res = nothing;

				while (low < high)
					{
					res = add(res, transform(self[low]));
					low = low + 1
					};
				return res
				}

			let mid = (low+high)/2;

			return merge(
				self.sum(transform,add,merge,low,mid,depth+1), 
				self.sum(transform,add,merge,mid,high,depth+1)
				)
			};

		return vectorSum
		};

({Vector}, `Member, `cumsum):
	fun(self, _, _)
		{
#Markdown(
"""#### Usage 

    v.cumsum()
    v.cumsum(transform = fun(x) { x }, add = fun(x, y) { x + y }, startValue = nothing)

#### Description

Return a vector of cumulative sums of a vector.

Case 1. is semantically equivalent to `Vector.range(size(v), fun(i) { v[,i].sum() })`.

Case 2 is semantically equivalent to `Vector.range(size(v), fun(i) { v[,i].sum(transform, add, add, startvalue) })`.

#### Examples

    Vector.range(10).cumsum()

""")
		fun() {
			let p = fun() {
				let res = nothing;
				for val in self {
					res = res + val
					yield res
					}
				}
			return `ProcessToVector(p())
			}
		(transform = fun(x) { x }, add = fun(x,y) { x + y }, startValue = nothing) {
			let p = fun() {
				let res = startValue;
				for val in self {
					res = add(res, transform(val));
					yield res
					}
				}
			return `ProcessToVector(p())
			}
		}
		;

({Vector}, `Member, `index):
    fun(vec, _, _) {
#Markdown("""
#### Usage

    vec.index(value)

#### Description

Find the index of the first occurrence of `value` in `vec`, 
else throw an exception.

#### Examples

    [1,2,3,3].index(3) // 2
    [1,2,3].index(4) // throws exception
""")
        fun(value) {
            let ix = 0;
            while (ix < size(vec)) {
                if (vec[ix] == value)
                    return ix
                ix = ix + 1;
                }
            throw "value not found"
            }
        };

//TODO FEATURE brax: a vector.apply that gives the index of the element as well
//as a value. v.apply( fun(val, ix){ ... } )
({Vector}, `Member, `applyWithIndex):
	fun (self, _, _)
		{
		let vectorApplyWithIndex =
#Markdown(
"""#### Usage

    v.applyWithIndex(f)

#### Description

Equivalent to calling `Vector.range(size(v), fun(ix) { f(v[ix], ix) })`

#### Examples

    [1.0, 2.0, 3.0].applyWithIndex(fun(v, ix){ (v, ix) })

""")
			fun(f) {
				Vector.range(
					(0,size(self)),
					fun(ix) { f(self[ix], ix) }
					)
				};
		vectorApplyWithIndex
		}
		;

({Vector}, `Operator, `~~, *):
	fun(v, _, _, transform) { 
		v.apply(transform)
		}
		;

({Vector}, `Member, `apply):
	fun (self, _, _)
		{
		let apply = 
#Markdown(
"""#### Usage

    v.apply(f)

#### Description

Applies 'f' to each element of the vector `v`, possibly using parallel resources.

Equivalent to calling `Vector.range(size(v), fun(i) { f(v[i]) })`.

#### Examples

	[1, 2, 3].apply(fun(x){x + 1})

""")
		fun(f) {
			Vector.range(
				(0,size(self)),
				fun(ix) { f(self[ix]) }
				)
			}

		apply
		}
		;

({Vector}, `Member, `filter):
	fun (self, _, _)
		{
#Markdown(
"""#### Usage

    v.filter(f)

#### Description

Pass each element of the vector `v` to `f`, keeping the ones that return logically true
values.

#### Examples

    [1, 2, 3, 4].filter(fun(x){ x % 2 == 0 })

""")
		fun(filter, *args) {
			let filterWrapper = fun(v,ix) { filter(v[ix]) };

			self.filterWithIndex(filterWrapper, *args)
			}
		}
		;

({Vector}, `Member, `filterWithIndex):
	fun (vec, _, _)
		{
		let vectorFilterWithIndex =
#Markdown(
"""#### Usage

    v.filterWithIndex(f)
    v.filterWithIndex(f, lowIndex=0, highIndex=size(v))

#### Description

For each value in the vector `v`, pass the vector and an index to `f`, and keep the values for which
the function returned logically true values.

If `lowIndex` and `highIndex` are provided, then this subrange of indices is used.

If either index is negative, the size of the vector is added to it.

#### Examples

    [1, 2, 3, 4].filterWithIndex(fun(v, ix){ v[ix] % 2 == 0 })

""")
			fun(f, lowIndex = 0, highIndex = size(vec), depth = 0) {
				if (highIndex < 0)
					highIndex = highIndex + size(vec);

				if (lowIndex < 0)
					lowIndex = lowIndex + size(vec);

				if (lowIndex == highIndex)
					return []

				if (lowIndex+1 == highIndex or depth > 10)
					{
					let result = []
					while (lowIndex < highIndex)
						{
						if (f(vec, lowIndex))
							result = result :: vec[lowIndex]

						lowIndex = lowIndex + 1
						}

					return result;
					}

				let midpoint = (lowIndex+highIndex)/2;

				return vectorFilterWithIndex(f,lowIndex,midpoint, depth+1) + 
						vectorFilterWithIndex(f,midpoint,highIndex,depth+1)
				};

		vectorFilterWithIndex
		}
		;


({Vector}, `Member, `split):
	fun(self, _, _)
		{
#Markdown("""
#### Usage

    v.split(splitFun, transform = fun(x) { x })

#### Description

Split a vector `v` according to predicate `splitFun`; pass each "chunk" produced to `transform`.

If the transformed chunk is not `nothing`, then we keep this transformed
value, and aggregate them into a vector.

#### Examples

    Vector.range(10).split(
        fun(x) { x % 3 == 0 }
        ) // returns [[], [1, 2], [4, 5], [7, 8], []];
	Vector.range(10).split(
        fun(x) { x % 3 == 0 }, 
        fun(chunk) { size(chunk) > 0 }
        ) // returns  [false, true, true, true, false]

""")
		fun(splitFun, transform = fun(x) { x })
			{
			let p = fun() {
				let ix = 0;
				let priorIx = 0;
				let sz = size(self);
				while (ix < sz)
					{
					let val = self[ix];
					if (splitFun(val))
						{
						let y = transform(self[priorIx, ix]);
						if (y is not nothing)
							yield y

						priorIx = ix + 1;
						};
					ix = ix + 1;
					};
				let y = transform(self[priorIx, ix]);
				if (y is not nothing)
					yield y;
				nothing
				};
			return `ProcessToVector(p())
			}
		}
		;


({Vector}, `Convert, String):
	fun(v, _, _) {
		String(v)
		}
		;

({Vector}, `Iter):
	fun(v, _) {
		let ix = 0;
		while (ix < size(v)) {
			yield v[ix]
			ix = ix + 1
			}
		}
		;


(nothing, `Next, *): fun(_, _, _) { nothing };
(nothing, `Iter):    fun(_, _)    { nothing };

(`ConvertYieldToIter, *, *):
	fun(_, valueToYield, continuation)  {
		object {
			...(`Iter) { self };
			...(`Next, arg) {
				(valueToYield, continuation`(arg))
				};
			}
		}
		;

//used by pyfora conversion
(`CheckValueIsPyforaInvalidVariableSymbol, *):
	fun (_, (PyforaUnconvertibleValue: _)) { throw nothing; }
		(_, valueToCheck) {
		if (valueToCheck is `PyforaUninitializedVariable) { throw nothing; }
		if (valueToCheck is `PyforaInvalidVariable) { throw nothing; }
		};

//TODO FEATURE:LANGUAGE brax: ability to extend built-in types
//
//add the following axiom:
//all non-object values have 'Unbind' just return a normal value.
//(`Unbind, `Call, *): fun(_,_,x) { x };
//
//Then extend the built-in types to support this:
//
//(Int64, *, {Int64}, `Operator, *, {Int64}):
//	fun(intType, self, baseInt, _, opSymbol, rhs) {
//		baseInt `( `Operator, opSymbol, rhs)
//		};
//

//by default, types try to convert things to them when called. if no
//conversion exists, we ask the object
({JOV}, `Call, *):
	fun(t, _, x if `TypeJOV(x) is t) { x }
	   (t, _, x) { 
           try {
               x `( `Convert, t) 
               }
           catch({String} _)
               {
               throw `Exception`().InvalidConversion(x, t)
               }
           }
	;

// Makes the ``FORTRANFunctionWrapper available in the UI as a regular symbol.
// TODO Find a way to hide this again.
(`FORTRANFunctionWrapper, `Call, ... *):
    fun(_, _, *args) {
        ``FORTRANFunctionWrapper(*args)
        }
        ;

(`InternalS3Dataset, `Call, ... *):
    fun(_, _, *args) {
        ``InternalS3Dataset(*args)
        }
        ;

