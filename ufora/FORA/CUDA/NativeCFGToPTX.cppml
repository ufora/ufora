/***************************************************************************
    Copyright 2015 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/


#include "NativeCFGToPTX.hppml"
#include "../Interpreter/RuntimeConfig.hppml"
#include "../Native/NativeCode.hppml"
#include "../Runtime.hppml"
#include "../../core/containers/ImmutableTreeVector.hppml"
#include "../../core/math/Alternative.hpp"
#include "../../core/Logging.hpp"
#include "../../core/STLOps.hpp"
#include <boost/lexical_cast.hpp>
#include <fstream>


using namespace std;


//representation of a FORA value in PTX registers
@type	PTXValueRepresentation =
			Atom of NativeType t, string ptxType, string registerName
		-|	Tuple of NativeType t,
							ImmutableTreeVector<PTXValueRepresentation> elts
		-|	Constant of string ptxExpr
		-|	Nothing of ()
{
public:
		string	 toString() const;
};

inline std::string bytesToHexStringReversed(unsigned char* data, uint32_t bytes)
	{
	ostringstream tr;

	for (long k = (long)bytes - 1; k >= 0; k--)
		tr << bytesToHexString(data + k, 1);

	return tr.str();
	}

string	PTXValueRepresentation::toString() const
	{
	@match PTXValueRepresentation(*this)
		-| Atom(_,_,registerName) ->> {
			return  registerName;
			}
		-| Constant(e) ->> {
			return  e;
			}
		-| _ ->> {
			lassert(false);
			return string();
			}
		;
	}

//representation of a 'continuation' in PTX
//has a block to jump to and a set of registers
//into which the continuation value should be placed
@type	PTXContinuationRepresentation =
				PTXValueRepresentation	targetRegisters,
				string					targetBlock
				;

//representation of an 'entrypoint' in PTX
//contains registers (for the arguments)
//and a jump point to go to
@type	PTXEntrypointRepresentation =
				ImmutableTreeVector<PTXValueRepresentation>	inputRegisters,
				string										targetBlock
				;

bool isByteInstruction(const NativeBinaryOpcode& opcode)
	{
	bool isByteInstruction = false;
	@match NativeBinaryOpcode(opcode)
			-| And() ->> {
				isByteInstruction = true;
				}
			-| Or() ->> {
				isByteInstruction = true;
				}
			-| Xor() ->> {
				isByteInstruction = true;
				}
			-| ShiftLeft() ->> {
				isByteInstruction = true;
				}
			-| ShiftRight() ->> {
				isByteInstruction = true;
				}
			-| _ ->> {
				isByteInstruction = false;
				}
			;
	return isByteInstruction;
	}

//takes a NativeType and returns a PTX type string representing it
//UInt1 is represented as a u32
//16,32,64 byte integers and 32,64 byte floats are supported
//any other type will cause it to throw UnableToConvertToPTX()
//isByteInstruction = true will cause us to write 'bXX' rather than
//	fXX, sXX or uXX, in case we are using this in bit instructions
string	nativeTypeToPTXType(
			const NativeType& inType,
			bool isByteInstruction = false,
			bool allowSmallestSize = false
			)
	{
	@match NativeType(inType)
		-| Integer(bits, sign) ->> {
				if (bits != 32 && bits != 64 &&
					bits != 16 && bits != 1 &&
					(!allowSmallestSize || bits != 8))
					throw UnableToConvertToPTX(
						"used an invalid integer type " +
							prettyPrintString(inType)
						);

				if (bits == 1)
					return isByteInstruction ? "b32" :  "u32";

				return (isByteInstruction ? "b" : sign ? "s":"u")
							+ boost::lexical_cast<string>(bits);
				}
		-| Float(bits) ->> {
				if (bits != 32 && bits != 64 &&
					(!allowSmallestSize || bits != 16))
					throw UnableToConvertToPTX(
						"used an invalid float type " + prettyPrintString(inType)
						);

				return (isByteInstruction ? "b" : "f")
					+ boost::lexical_cast<string>(bits);
				}
		-| Pointer(t) ->> {
				return "u64";
				}
		-| _ ->> {
				throw UnableToConvertToPTX(
						"used an invalid type " + prettyPrintString(inType)
						);
				}
		;
	}

//simple class to track use of registers
class PTXRegisterAllocator : public boost::noncopyable {
public:
	//returns a uniquely named register of the given PTX type
	string		newRegisterName(const string& type)
		{
		mRegisterTypeCount[type]++;

		return "%reg_" + type + "_" +
				boost::lexical_cast<string>(mRegisterTypeCount[type]-1);
		}
	string	allocatePredicate(void)
		{
		return newRegisterName("pred");
		}
	PTXValueRepresentation	allocateValue(const NativeType& inType)
		{
		@match NativeType(inType)
			-| Nothing() ->> {
				return  PTXValueRepresentation::Nothing();
				}
			-| Integer() ->> {
					string ptxType = nativeTypeToPTXType(inType);
					return PTXValueRepresentation::Atom(
						inType,
						ptxType,
						newRegisterName(ptxType)
						);
					}
			-| Float() ->> {
					string ptxType = nativeTypeToPTXType(inType);

					return PTXValueRepresentation::Atom(
						inType,
						ptxType,
						newRegisterName(ptxType)
						);
					}
			-| Composite(t) ->> {
					ImmutableTreeVector<PTXValueRepresentation> result;

					for (long k = 0; k < t.size();k++)
						result = result + allocateValue(t[k]);

					return PTXValueRepresentation::Tuple(inType, result);
					}
			-| Pointer(t) ->> {
				string ptxType = nativeTypeToPTXType(inType);
				return PTXValueRepresentation::Atom(
						inType,
						ptxType,
						newRegisterName(ptxType)
						);
				}
			-| _ ->> {
				throw UnableToConvertToPTX(
						"don't know how to register allocate type: " + prettyPrintString(inType)
						);
				}
			;
		}

	string		registerAllocationString() const
		{
		ostringstream	str;

		for (map<string, uint32_t>::const_iterator
						it = mRegisterTypeCount.begin(),
						it_end = mRegisterTypeCount.end();
					it != it_end;
					++it)
			str	<< ".reg\t"						//declare the register
				<< "." << it->first << "\t"		//give it a type
				<< "%reg_" << it->first			//give it a name
				<< "_<" << it->second << ">"	//state how many
				<< ";\n";						//terminate the statement

		return str.str();
		}
private:
	map<string, uint32_t>	 mRegisterTypeCount;
};

//converts a NativeCFG to nvidia's PTX code format
//NativeCFG must be a very specific kind of CFG

class NativeToPTXConverter {
public:
	NativeToPTXConverter(
				const NativeCFG& inCFG,
				const string& inEntryFunctionName,
				const string& ptxLibPath) :
			mBlockIndex(0), mPtxLibPath(ptxLibPath)
		{
		buildResult(inCFG, inEntryFunctionName);
		}

	string	getResult() const
		{
		return mResult;
		}
private:
	static std::string doubleToPtxConstant(double v)
		{
		return "0d" + bytesToHexStringReversed(
			(unsigned char*)&v,
			sizeof(v)
			);
		}

	void buildResult(const NativeCFG& inCFG, string inEntryFunctionName)
		{
		auto returnTypesCount = inCFG.returnTypes().size();
		bool hasMultipleReturnTypes = returnTypesCount > 1 ? true : false;

		// at least one and at most two of the inputs should be not "Nothing",
		// the first is the input data
		Nullable<uint32_t> inputIndex, closureIndex;
		uint32_t inCFGArgsSize = inCFG[NativeBlockID::entry()].args().size();
		for (long k = 0; k < inCFGArgsSize; k++)
			if (!inCFG[NativeBlockID::entry()].args()[k].type().isNothing())
				{
				if (inputIndex)
					{
					if (closureIndex)
						{
						throw UnableToConvertToPTX(
							"function has multiple arguments"
							);
						}
					else
						{
						closureIndex = inputIndex;
						inputIndex = k;
						}
					}
				else
					inputIndex = k;
				}
		if (!inputIndex)
			throw UnableToConvertToPTX("CFG had no inputs");

		NativeType	inputType =
			inCFG[NativeBlockID::entry()].args()[*inputIndex].type();

		//get the terminal continuation
		string	exitBlockName = allocateBlockName("exit_");

		PTXContinuationRepresentation	terminalContinuation(
					PTXValueRepresentation::Nothing(),
					exitBlockName
					);

		NativeType	closureType = (closureIndex) ?
					inCFG[NativeBlockID::entry()].args()[*closureIndex].type() :
					NativeType::Nothing();
		NativeVariable closureVar = NativeVariable::Temp(closureType);
		NativeVariable closurePtr = NativeVariable::Temp(closureType.ptr());

		NativeType offsetType = NativeType::uint64();
		NativeType indexType  = NativeType::uint8();
		NativeVariable inputVar = NativeVariable::Temp(inputType);
		NativeVariable inputPtr = NativeVariable::Temp(inputType.ptr());
		NativeVariable offsetVar = NativeVariable::Temp(offsetType);
		NativeVariable indexPtr = NativeVariable::Temp(indexType.ptr());

		ImmutableTreeVector<NativeExpression> args = emptyTreeVec();
		for (long k = 0; k < inCFGArgsSize; k++)
			{
			if (k == *inputIndex)
				args = args + inputVar.expr();
			else if (closureIndex && k == *closureIndex)
				args = args + closureVar.expr();
			else
				args = args + inCFG[NativeBlockID::entry()].args()[k].expr();
			}

		ImmutableTreeVector<NativeContinuation> conts = emptyTreeVec();
		ImmutableTreeVector<NativeVariable> outputPointers = emptyTreeVec();
		long idx = 0;
		for (auto& outputType : inCFG.returnTypes())
			{
			LOG_DEBUG << "outputType = " << prettyPrintString(outputType);
			NativeVariable outputVar = NativeVariable::Temp(outputType);
			NativeVariable outputPtr = NativeVariable::Temp(outputType.ptr());
			outputPointers = outputPointers + outputPtr;
			NativeExpression storeVecExpr =
					NativeExpression::Store(
							NativeExpression::BinaryOp(
									NativeBinaryOpcode::Add(),
									outputPtr.expr(),
									offsetVar.expr()
									),
							outputVar.expr()
							);
			if (hasMultipleReturnTypes)
				{
				NativeExpression storeIdxExpr =
						NativeExpression::Store(
								NativeExpression::BinaryOp(
										NativeBinaryOpcode::Add(),
										indexPtr.expr(),
										offsetVar.expr()
										),
								NativeExpression::ConstantUInt8(idx)
								);
				conts = conts +
						NativeContinuation(
								outputVar,
								NativeExpression::DiscardFirst(storeVecExpr, storeIdxExpr)
								);
				}
			else
				conts = conts + NativeContinuation(outputVar, storeVecExpr);
			++idx;
			}


		NativeExpression nexp =
			NativeExpression::DiscardFirst(
				NativeExpression::Let(
					inputVar,
					NativeExpression::Load(
							NativeExpression::BinaryOp(
									NativeBinaryOpcode::Add(),
									inputPtr.expr(),
									offsetVar.expr()
									)
							, false
							),
					NativeExpression::Call(
							NativeCallTarget::Inline(inCFG, NativeBlockID::entry()),
							conts,
							args,
							emptyTreeVec() /*+ NativeContinuationMetadata meta*/
							)
				),
				NativeExpression::Return(0, NativeConstant::Nothing().expr())
			);

		auto wrappedCFGArgs = inCFG[NativeBlockID::entry()].args() + offsetVar + inputPtr + outputPointers;
		if (closureIndex)
			{
			nexp =
					NativeExpression::Let(
						closureVar,
						NativeExpression::Load(closurePtr.expr(), false),
						nexp
						);
			wrappedCFGArgs = wrappedCFGArgs + closurePtr;
			}
		if (hasMultipleReturnTypes)
			wrappedCFGArgs = wrappedCFGArgs + indexPtr;

		NativeCFG wrappedCFG =
				NativeCFG(
						emptyTreeVec(),
						wrappedCFGArgs,
						nexp,
						"wrappedCUDANativeCFG"
						);

		LOG_DEBUG << "wrappedCFG::\n\n" << prettyPrintString(wrappedCFG);
		pair<string, PTXEntrypointRepresentation>
				body = computeBody(	wrappedCFG,
									NativeBlockID::entry(),
									emptyTreeVec() + terminalContinuation
									);


		std::vector<std::string>  paramOutputPtrNames(returnTypesCount);
		std::vector<std::string>  regOutputPtrNames(returnTypesCount);
		for (long k=0; k < returnTypesCount; ++k)
			{
			std::ostringstream s1;
			s1 << "reg_outputPtr_" << k;
			regOutputPtrNames[k] = s1.str();

			std::ostringstream s2;
			s2 << "paramOutputPtr" << k;
			paramOutputPtrNames[k] = s2.str();
			}

		ostringstream result;

		std::ifstream libFile(mPtxLibPath);
		if (libFile)
			{
			result << libFile.rdbuf();
			}

		result 		<<	".entry " << inEntryFunctionName << " (\n";
		if (closureIndex)
			result 	<<	"\t\t.param .u64 closurePtr,\n";
		result
					<<	"\t\t.param .u32 N,\n"
					<<	"\t\t.param .u64 inputPtr,\n";
		if (hasMultipleReturnTypes)
			result	<<	"\t\t.param .u64 indexPtr,\n";
		for (long k=0; k < returnTypesCount - 1; ++k)
			result	<<	"\t\t.param .u64 " << paramOutputPtrNames[k] << ",\n";
		result 		<<	"\t\t.param .u64 " << paramOutputPtrNames[returnTypesCount-1] << ")\n";

		result	<<	"{\n";
		result << mRegisters.registerAllocationString();
		if (closureIndex)
			result 	<< 	".reg		.u64		reg_closurePtr;\n";
		if (hasMultipleReturnTypes)
			result	<<	".reg		.u64		reg_indexPtr;\n";
		result
				<<	".reg		.u32		reg_N;\n"
				<<	".reg		.u64		reg_inputPtr;\n"
				<<	".reg		.pred		validApplyPredicate;\n"
				<<	".reg		.u32		numthreads;\n"
				<<	".reg		.u32		blockX;\n"
				<<	".reg		.u32		threadID;\n"
				<<	".reg		.u32		i;\n"
				<<	".reg		.u32		i_temp;\n"
				<<	".reg		.u64		i64;\n";

		for (long k=0; k < returnTypesCount; ++k)
			result <<	".reg		.u64		" << regOutputPtrNames[k] <<";\n";

				//load the relevant environment values into registers
		result	<<	"mov.u32		numthreads, %ntid.x;\n"
				<<	"mov.u32		blockX, %ctaid.x;\n"
				<<	"mov.u32		threadID, %tid.x;\n"
				;
		if (closureIndex)
			result << "ld.param.u64		reg_closurePtr, [closurePtr];\n";
		if (hasMultipleReturnTypes)
			result	<<	"ld.param.u64	reg_indexPtr, [indexPtr];\n";
		result
				<<	"ld.param.u32		reg_N, [N];\n"
				<<	"ld.param.u64		reg_inputPtr, [inputPtr];\n"
				;
		for (long k=0; k < returnTypesCount; ++k)
			result	<<	"ld.param.u64		" << regOutputPtrNames[k] << ", ["
					<< paramOutputPtrNames[k] << "];\n";
				//compute 'i', the particular position we're in
		result
				<<	"mul.lo.u32		i_temp,	numthreads,	blockX;\n"
				<<	"add.u32		i, i_temp, threadID;\n"
				//check whether 'i' is less than 'N' and exit if not
				<<	"cvt.u64.u32		i64,		i;\n"
				<<	"setp.ge.u32		validApplyPredicate, i, reg_N;\n"
				<<	"@validApplyPredicate	bra	done;\n"
				//this is a valid 'i', so we should execute the client code
				;

		uint32_t argOffset = inCFGArgsSize;
		copyFromPTXToPTX(
				PTXValueRepresentation::Atom(offsetType, "u64", "i64"),
				body.second.inputRegisters()[argOffset++],
				result
				);
		copyFromPTXToPTX(
				PTXValueRepresentation::Atom(inputType.ptr(), "u64", "reg_inputPtr"),
				body.second.inputRegisters()[argOffset++],
				result
				);
		for (long k=0; k < returnTypesCount; ++k)
			copyFromPTXToPTX(
					PTXValueRepresentation::Atom(inCFG.returnTypes()[k].ptr(), "u64", regOutputPtrNames[k]),
					body.second.inputRegisters()[argOffset++],
					result
					);
		if (closureIndex)
			{
			copyFromPTXToPTX(
					PTXValueRepresentation::Atom(closureType.ptr(), "u64", "reg_closurePtr"),
					body.second.inputRegisters()[argOffset++],
					result
					);
			}
		if (hasMultipleReturnTypes)
			{
			copyFromPTXToPTX(
					PTXValueRepresentation::Atom(indexType, "u8", "reg_indexPtr"),
					body.second.inputRegisters()[argOffset++],
					result
					);
			}
		//now branch into the continuation. this is unnecessary (Because
		//we'll flow right into it) but we leave it in so that when
		//we expand the code generator it'll be consistent
		result << "bra		" << body.second.targetBlock() << ";\n";

		//write the body itself
		result << body.first;

		//generate the output continuation
		result << "// generate the output continuation\n";
		result << terminalContinuation.targetBlock() + ":\n";

		//write the "done" block
		result << "done:\n";
		result << "exit;\n";

		//finish it off
		result << "}\n";
		LOG_DEBUG << "PTX:\n\n" << result.str();

		mResult = result.str();
		}

	//generates a string of 'ld.global' instructions
	//that load pointer offset values from 'inPointerName' into
	//the registers specified in "ptxRegisters"
	string	loadValueFromPointerIntoRegisters(
							const PTXValueRepresentation&	inPointer,
							const PTXValueRepresentation&	ptxRegisters,
							uword_t							offset = 0
							)
		{
		@match PTXValueRepresentation(inPointer)
			-|	Nothing() ->> {
				return "";
				}
			-|	Atom(nativeType, ptxType, regName) ->> {
				return loadValueFromPointerIntoRegisters(regName, ptxRegisters, offset);
				}
			-| 	_ ->> {
				return "";
				}
			;
		}
	string	loadValueFromPointerIntoRegisters(
							const string&					inPointerName,
							const PTXValueRepresentation&	ptxRegisters,
							uword_t							offset = 0
							)
		{
		@match	PTXValueRepresentation(ptxRegisters)
			-| Nothing()	->> {
				return  "";
				}
			-| Atom(nativeType, ptxType, regName) ->> {
				return
					//something like
					//	ld.global.f32	regname, [ptrname+offset];
					"ld.global." + ptxType + "\t" + regName + ", " +
						"[" + inPointerName + "+" +
								boost::lexical_cast<string>(
										alignedOffset(nativeType, offset)
										) + "];\n"
					;
				}
			-| Tuple(nativeType, registers) ->> {
				string tr;

				for (long k = 0; k < registers.size(); k++)
					{
					tr = tr + loadValueFromPointerIntoRegisters(
									inPointerName,
									registers[k],
									offset
									);
					offset =
							alignedOffset(nativeType.getComposite().elements()[k], offset) +
							nativeType.getComposite().elements()[k].alignedSize();
					}
				return tr;
				}
			;
		}
	string	writeValueToPointer(
							const PTXValueRepresentation&	inPointer,
							const PTXValueRepresentation&	inValue,
							uword_t							offset = 0
							)
		{
		@match PTXValueRepresentation(inPointer)
			-|	Nothing() ->> {
				return "";
				}
			-|	Atom(nativeType, ptxType, regName) ->> {
				auto pointedType = nativeType.deref();
				return writeValueToPointer(regName, pointedType, inValue, offset);
				}
			-| 	_ ->> {
				return "";
				}
			;
		}

	//generates a string of 'st.global' instructions
	//that store register values into a pointer given by "inPointerName"
	string	writeValueToPointer(
							const string&					inPointerName,
							const NativeType&				pointedType,
							const PTXValueRepresentation&	ptxRegisters,
							uword_t							offset = 0
							)
		{
		@match	PTXValueRepresentation(ptxRegisters)
			-| Nothing()	->> {
				return  "";
				}
			-| Atom(nativeType, ptxType, regName) ->> {
				string pointedPtxType = nativeTypeToPTXType(pointedType, false, true);
				lassert_dump( pointedPtxType == ptxType,
							"incompatible value ptx-type '" << ptxType << "' for pointer to '"
							<< pointedPtxType);
					//something like
					//	st.global.f32	[ptrname+offset], regname;
				return
					"st.global." + ptxType +
						//generate the pointer offset
						"\t[" + inPointerName + "+" +
								boost::lexical_cast<string>(
										alignedOffset(nativeType, offset)
										) + "]" +
							", " +
						//the register
						regName + ";\n";
				}
			-| Tuple(nativeType, registers) ->> {
				ostringstream tr;
				lassert(nativeType.isComposite());
				auto nativeTypes = nativeType.getComposite().elements();
				for (long k = 0; k < registers.size();k++)
					{
					tr << writeValueToPointer(
									inPointerName,
									nativeTypes[k],
									registers[k],
									offset
									);
					offset =
							alignedOffset(nativeType.getComposite().elements()[k], offset) +
							nativeType.getComposite().elements()[k].alignedSize();
					}
				return tr.str();
				}
			-|	Constant(expr) ->> {
				string ptxType = nativeTypeToPTXType(pointedType, false, true);
				return
					"st.global." + ptxType +
						"\t[" + inPointerName + "+" +
								boost::lexical_cast<string>(
										alignedOffset(pointedType, offset)
										) + "]" +
						", " +
						//the register
						expr + ";\n";
				}
			-|	Nothing() ->> {
				lassert_dump(false, "'Nothing' found in writeValueToPointer");
				}
			;
		}

	//compute a PTX definition of a NativeCFG
	pair<string, PTXEntrypointRepresentation>
				computeBody(const NativeCFG& inCFG,
							NativeBlockID inToCall,
							ImmutableTreeVector<PTXContinuationRepresentation>
										inContinuations
							)
		{
		ImmutableTreeMap<NativeBlockID, PTXEntrypointRepresentation>
			entrypoints;

		ostringstream body;

		for (long k = 0; k < inCFG.blocks().size();k++)
			{
			ImmutableTreeVector<PTXValueRepresentation> arguments;

			NativeBlockID blockID = inCFG.blocks().pairAtPosition(k).first;
			NativeBlock	block = inCFG.blocks().pairAtPosition(k).second;

			for (long j = 0; j < block.args().size(); j++)
				{
				arguments = arguments +
					mRegisters.allocateValue(
						block.args()[j].type()
						);
				}

			PTXEntrypointRepresentation	input(
						arguments,
						allocateBlockName("block")
						);

			entrypoints = entrypoints + blockID + input;
			}

		for (long k = 0; k < inCFG.blocks().size(); k++)
			{
			NativeBlockID blockID = inCFG.blocks().pairAtPosition(k).first;
			NativeBlock	block = inCFG.blocks().pairAtPosition(k).second;

			body	 << "//entrypoint for block "
					<< prettyPrintString(blockID) << "\n"
					;

			body << entrypoints[blockID]->targetBlock() << ":\n";

			ImmutableTreeMap<NativeVariable, PTXValueRepresentation>
				localVariables;

			ImmutableTreeVector<PTXValueRepresentation> arguments =
				entrypoints[blockID]->inputRegisters();

			lassert(arguments.size() == block.args().size());

			for (long k = 0; k < block.args().size(); k++)
				localVariables = localVariables +
					block.args()[k] +
					arguments[k]
					;

			Nullable<PTXValueRepresentation> bodyVR =
				computeExpression(
					block.expression(),
					inContinuations,
					entrypoints,
					localVariables,
					body
					);
			lassert_dump(bodyVR && bodyVR->isNothing(),
				"root CFG expression returned a value other than Nothing, which makes no sense"
				);

			}

		return
			make_pair(
				body.str(),
				*entrypoints[inToCall]
				);
		}
	Nullable<PTXValueRepresentation>
		computeBinaryOpWithPointerArithmetic(
				const NativeBinaryOpcode& opcode,
				const NativeExpression& ptr,
				const NativeExpression& offset,
				const PTXValueRepresentation& ptrVal,
				const PTXValueRepresentation& offsetVal,
				ostringstream&	ioSideEffectStream
				)
	{
	lassert(ptr.type()->isPointer());
	const NativeType& pointedType = ptr.type()->getPointer().element();
	string ptxInstruction;
	@match NativeBinaryOpcode(opcode)
			-| Add() ->> {
				ptxInstruction =  "mad.lo";
				}
			-| _ ->> {
				throw UnableToConvertToPTX(
						"cannot perform pointer arithmetic with operator "
						+ prettyPrintString(opcode));
				}
	PTXValueRepresentation outReg =
		mRegisters.allocateValue(*ptr.type());
	//write a comment so we can tell what is
	//going on in the PTX string
	ioSideEffectStream << "// "
		<< prettyPrintString(opcode) << " on "
		<< prettyPrintString(*ptr.type()) << " and "
		<< prettyPrintString(*offset.type()) << "\n"
		;
	//write an instruction pushing this into the new value
	ioSideEffectStream
		<< ptxInstruction << "."
		<< nativeTypeToPTXType(
				*ptr.type(),
				isByteInstruction(opcode)
				)
		<< "\t"
		//write the target register
		<< outReg.getAtom().registerName() << ", "
		<< offsetVal.toString() << ", "
		<< pointedType.alignedSize() << "U" << ", "
		<< ptrVal.toString()
		<< ";\n"
		;

	//the output register is the relevant one
	return null() << outReg;

	}

	//compute the PTX text representation of an expression
	//given the environment in which the expression is being
	//evaluated.  Returns 'null()' if the expression doesn't
	//return a value. otherwise, returns the relevant registers
	Nullable<PTXValueRepresentation>
		computeExpression(
				const NativeExpression& inNativeExpression,
				const ImmutableTreeVector<PTXContinuationRepresentation>&
					inContinuations,
				const ImmutableTreeMap<
							NativeBlockID,
							PTXEntrypointRepresentation>&
					inEntrypoints,
				const ImmutableTreeMap<
							NativeVariable,
							PTXValueRepresentation>&
					inLocalVariables,
				ostringstream&	ioSideEffectStream
				)
		{
		@match NativeExpression(inNativeExpression)
			-| Constant(NullPointer()) ->>
					{ throw UnableToConvertToPTX(
											"can't use NullPointer"); }
			-| Constant(VoidPtr()) ->>
					{ throw UnableToConvertToPTX("cant use VoidPtr"); }
			-| Constant(Nothing()) ->> {
					return null() << PTXValueRepresentation::Nothing();
					}
			-| Constant(c) ->> {
					string s;
					@match NativeConstant(c)
							-| Double(v) ->> {
								s = doubleToPtxConstant(v);
								}
							-| Float(v) ->> {
								s =   (
									"0f" + bytesToHexStringReversed(
												(unsigned char*)&v,
												sizeof(v))
									);
								}
							-| Bool(v) ->> {
								s =   (
									v ? "1U":"0U"
									);
								}
							-| UInt8(v) ->> {
								s =   (
									boost::lexical_cast<string>((unsigned int)v) + "U"
									);
								}
							-| UInt16(v) ->> {
								s =   (
									boost::lexical_cast<string>(v) + "U"
									);
								}
							-| UInt32(v) ->> {
								s =   (
									boost::lexical_cast<string>(v) + "U"
									);
								}
							-| UInt64(v) ->> {
								s =   (
									boost::lexical_cast<string>(v) + "U"
									);
								}
							-| Int8(v) ->> {
								s =   (
									boost::lexical_cast<string>(v)
									);
								}
							-| Int16(v) ->> {
								s =   (
									boost::lexical_cast<string>(v)
									);
								}
							-| Int32(v) ->> {
								s =   (
									boost::lexical_cast<string>(v)
									);
								}
							-| Int64(v) ->> {
								s =   (
									boost::lexical_cast<string>(v)
									);
								}
							-| ArbitraryConstant() ->> {
									throw UnableToConvertToPTX(
											"can't use an arbitrary constant here: " +
												prettyPrintString(c));
									}
							;
					return null() << PTXValueRepresentation::Constant(s);
					}
			-| Tagged(e, tag) ->> {
					return computeExpression(e,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);
					}
			-| Variable(v) ->> {
					Nullable<const PTXValueRepresentation&> varRep = inLocalVariables[v];
					if (!varRep)
						throw UnableToConvertToPTX(
								"unknown variable :" + prettyPrintString(v));
					return null() << *inLocalVariables[v];
					}
			-| DiscardFirst(e1, e2) ->> {
					computeExpression(e1,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);
					return computeExpression(e2,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);
					}
			-| CreateComposite(subs) ->> {
					ImmutableTreeVector<PTXValueRepresentation> vals;
					for (long k = 0; k < subs.size();k++)
						{
						Nullable<PTXValueRepresentation> val =
							computeExpression(subs[k],
								inContinuations,
								inEntrypoints,
								inLocalVariables,
								ioSideEffectStream
								);
						if (!val)
							return null();
						vals = vals + *val;
						}
					lassert_dump(
						inNativeExpression.type(),
						"every subexpression returned a value, but the "
						"NativeExpression doesn't have a type, which makes "
						"no sense.");

					return null() << PTXValueRepresentation::Tuple(
							*inNativeExpression.type(),
							vals
							);
					}
			-| Zero(Nothing()) ->> {
					return null() << PTXValueRepresentation::Nothing();
					}
			-| Zero(Integer(bits, sign)) ->> {
					return null() << PTXValueRepresentation::Constant(
						"0" + string(sign ? "U":"")
						);
					}
			-| Zero(Float(bits)) ->> {
					return null() <<
								PTXValueRepresentation::Constant("0.0");
					}
			-| BinaryOp(opcode, lhsE, rhsE) ->> {

				NativeExpression lhs = lhsE;
				NativeExpression rhs = rhsE;

				Nullable<PTXValueRepresentation> lhsVal =
					computeExpression(lhs,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				if (!lhsVal)
					return null();

				if (opcode.isShiftLeft() || opcode.isShiftRight())
					rhs = NativeExpression::Cast(NativeType::uint32(), rhs, false);

				Nullable<PTXValueRepresentation> rhsVal =
					computeExpression(rhs,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				if (!rhsVal)
					return null();

				//this can remain a constant expression
				if (lhsVal->isConstant() && rhsVal->isConstant())
					{
					string operand;
						@match NativeBinaryOpcode(opcode)
							-| Add() ->> {
								operand = "+";
								}
							-| Sub() ->> {
								operand =  "-";
								}
							-| Mul() ->> {
								operand =  "*";
								}
							-| Div() ->> {
								operand =  "/";
								}
							-| Mod() ->> {
								operand =  "%";
								}
							-| And() ->> {
								operand =  "&";
								}
							-| Or() ->> { operand ="|"; }
							-| Xor() ->> {
								operand =  "^";
								}
							-| ShiftLeft() ->> {
								operand =  "<<";
								}
							-| ShiftRight() ->> {
								operand =  ">>";
								}
							-| Power() ->> {
								throw UnableToConvertToPTX(
									"'power' is not implemented in PTX yet");
								}
							-| LT() ->> {
								operand =  "<";
								}
							-| LTE() ->> {
								operand =  "<=";
								}
							-| GT() ->> {
								operand =  ">";
								}
							-| GTE() ->> {
								operand =  ">=";
								}
							-| EQ() ->> {
								operand =  "==";
								}
							-| NEQ() ->> {
								operand =  "!=";
								}
							;

					return null() << PTXValueRepresentation(
						"((" + lhsVal->getConstant().ptxExpr() + ")"
						+ operand +
						"((" + rhsVal->getConstant().ptxExpr() + ")"
						);
					}

				if (*lhs.type() == NativeType::uint1() &&
					*rhs.type() == NativeType::uint1())
					{
					//these values are represented as predicates
					//so we can't use our regular operations on them
					lassert(false);
					}

				// detect and deal with pointer arithmetic
				if (lhs.type()->isPointer() && rhs.type()->isInteger())
					return computeBinaryOpWithPointerArithmetic(
							opcode, lhs, rhs, *lhsVal, *rhsVal, ioSideEffectStream);
				else if (rhs.type()->isPointer() && lhs.type()->isInteger())
					return computeBinaryOpWithPointerArithmetic(
							opcode, rhs, lhs, *rhsVal, *lhsVal, ioSideEffectStream);

				//not a constant expression nor pointer arithmetic.
				// allocate a register for the output
				PTXValueRepresentation outReg =
					mRegisters.allocateValue(*inNativeExpression.type());

				lassert_dump(*lhs.type() == *rhs.type(), "can't use differing types"
					<< " for operations in PTX. "
					<< prettyPrintString(*lhs.type())
					<< " != " << prettyPrintString(*rhs.type())
					<< ". op = " << prettyPrintString(opcode)
					);

				string ptxInstruction;
				@match NativeBinaryOpcode(opcode)
						-| Add() ->> {
							ptxInstruction =  "add";
							}
						-| Sub() ->> {
							ptxInstruction =  "sub";
							}
						-| Mul() ->> {
							ptxInstruction =  (lhs.type()->isInteger() ?
											"mul.lo" : "mul");
							}
						-| Div() ->> {
							ptxInstruction =  (lhs.type()->isInteger() ?
											"div" : "div.rn");
							}
						-| Mod() ->> {
							ptxInstruction =  "rem";
							}
						-| And() ->> {
							ptxInstruction =  "and";
							}
						-| Or() ->> {
							ptxInstruction =  "or";
							}
						-| Xor() ->> {
							ptxInstruction =  "xor";
							}
						-| ShiftLeft() ->> {
							ptxInstruction =  "shl";
							}
						-| ShiftRight() ->> {
							ptxInstruction =  "shr";
							}
						-| Power() ->> {
							throw UnableToConvertToPTX(
								"'power' is not implemented in PTX yet"
								);
							}
						-| LT() ->> {
							ptxInstruction =  "set.lt";
							}
						-| LTE() ->> {
							ptxInstruction =  "set.le";
							}
						-| GT() ->> {
							ptxInstruction =  "set.gt";
							}
						-| GTE() ->> {
							ptxInstruction =  "set.ge";
							}
						-| EQ() ->> {
							ptxInstruction =  "set.eq";
							}
						-| NEQ() ->> {
							ptxInstruction =  "set.ne";
							}
						;

				//write a comment so we can tell what is
				//going on in the PTX string
				ioSideEffectStream << "// "
					<< prettyPrintString(opcode) << " on "
					<< prettyPrintString(*lhs.type()) << " and "
					<< prettyPrintString(*rhs.type()) << "\n"
					;


				//write an instruction pushing this into the new
				//value
				ioSideEffectStream
					<< ptxInstruction
					;

				//write the dest type
				ioSideEffectStream << "."
					<< nativeTypeToPTXType(
							*inNativeExpression.type(),
							isByteInstruction(opcode)
							);
				if (opcode.isComparison())
					{
					//write the arg type as well
					ioSideEffectStream << "."
						<< nativeTypeToPTXType(*lhs.type());
					}



				ioSideEffectStream
					//write the target register
					<< "\t" << outReg.getAtom().registerName()
					//write the lhs value
					<< ", " << lhsVal->toString()
					<< ", " << rhsVal->toString()
					<< ";\n"
					;

				//the output register is the relevant one
				return null() << outReg;
				}
			-| UnaryOp(NOT(), lhs) ->> {
				//TODO CLEANUP brax: be careful about types, and
				//document what intended usage is in NativeCode model.
				throw UnableToConvertToPTX("NOT not implemented yet");
				}
			-| UnaryOp(opcode, lhs) ->> {

				Nullable<PTXValueRepresentation> lhsVal =
					computeExpression(lhs,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				if (!lhsVal)
					return null();

				//get a register for the output
				PTXValueRepresentation outReg =
					mRegisters.allocateValue(*inNativeExpression.type());

				//generate an instruction
				string ptxInstruction;
				bool isCall = false;
				@match NativeUnaryOpcode(opcode)
					-| Negate() ->> {
						ptxInstruction =   "neg";
						}
					-| Sin() ->> {
						isCall = true;
						ptxInstruction =   "sinf64";
						}
					-| Cos() ->> {
						isCall = true;
						ptxInstruction =   "cosf64";
						}
					-| Log() ->> {
						isCall = true;
						ptxInstruction =   "logf64";
						}
					-| Exp() ->> {
						isCall = true;
						ptxInstruction =   "expf64"
						}
						;

				//write a comment so we can tell what is
				//going on in the PTX string
				ioSideEffectStream << "// "
					<< prettyPrintString(opcode) << " on "
					<< prettyPrintString(*lhs.type()) << "\n"
					;

				//write an instruction pushing this into the new
				//value
				if (isCall)
					ioSideEffectStream
						<< "call (" << outReg.getAtom().registerName() << "), "
						<< ptxInstruction
						<< ", ("
						<< lhsVal->toString() << ")"
						<< ";\n"
						;
				else
					ioSideEffectStream
						<< ptxInstruction
						<< "." << nativeTypeToPTXType(*inNativeExpression.type())
						//write the target register
						<< " " << outReg.getAtom().registerName()
						//write the lhs value
						<< ", " << lhsVal->toString()
						<< ";\n"
						;

				return null() << outReg;
				}
			/*
			-| Selector(c,ifTrue,ifFalse) ->> {

				//if condE is not a boolean,
				//compare it against 'zero'
				NativeExpression condE = c;
				if (condE.type()
						&& *condE.type() != NativeType::Integer(1,false))
					condE = NativeExpression::BinaryOp(
								NativeBinaryOpcode::NEQ(),
								condE,
								NativeExpression::Zero(*condE.type())
								);

				Nullable<PTXValueRepresentation> condVal =
					computeExpression(condE,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				Nullable<PTXValueRepresentation> ifTrueVal =
					computeExpression(ifTrue,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				Nullable<PTXValueRepresentation> ifFalseVal =
					computeExpression(ifFalse,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				//branching code. condVal is a predicate
				//allocate a target register
				PTXValueRepresentation outReg =
					mRegisters.allocateValue(*inNativeExpression.type());

				lassert(ifTrue.type() == ifFalse.type());

				//TODO CLEANUP brax: allow selector to work on tuples
				lassert_dump(!ifTrue.type()->isComposite(),
					"Selector not implemented for tuples on GPU yet");

				ioSideEffectStream
					//write the instruction
					<< "selp." << nativeTypeToPTXType(*ifTrue.type())
					//destination register
					<< " "   << outReg.toString()
					//arguments
					<< ",  " << condVal->toString()
					<< ",  " << ifTrueVal->toString()
					<< ",  " << ifFalseVal->toString()
					//terminate the statement
					<< ";\n"
					;

				return null() << outReg;
				}*/
			-| Cast(destType, sourceExpression, forceBitcast) ->> {
				if (forceBitcast)
					{
					ostringstream msg;
					msg << "tried to convert bitcast to PTX (unsupported): "
						<< prettyPrintString(inNativeExpression);
					throw UnableToConvertToPTX(msg.str());
					}
				Nullable<PTXValueRepresentation> sourceVal =
					computeExpression(sourceExpression,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				//this will just bail
				if (!sourceVal)
					return sourceVal;

				//allocate a register
				PTXValueRepresentation outReg =
					mRegisters.allocateValue(*inNativeExpression.type());

				if (!(destType.isInteger() || destType.isFloat())
					|| !(sourceExpression.type()->isInteger() ||
						sourceExpression.type()->isFloat()))
					{
					ostringstream msg;
					msg << "tried to convert cast between something other than "
						<< "int/float to PTX (unsupported): ["
						<< prettyPrintString(destType) << " <- "
						<< prettyPrintString(*sourceExpression.type()) << "]: "
						<< prettyPrintString(inNativeExpression);
					throw UnableToConvertToPTX(msg.str());
					}
				ioSideEffectStream
					<<	 "cvt"
					;

				//FORA rounds towards zero on float->int conversion
				if (destType.isInteger() &&
						sourceExpression.type()->isFloat())
					ioSideEffectStream << ".rzi";

				//round the mantissa to nearest even
				if (destType.isFloat() &&
						(sourceExpression.type()->isInteger()
								|| sourceExpression.type()->alignedSize() > destType.alignedSize()))
					ioSideEffectStream << ".rn";

				ioSideEffectStream
					//destination type
					<<	 "." << nativeTypeToPTXType(destType)
					//source type
					<<	"." << nativeTypeToPTXType(*sourceExpression.type())
					//arguments
					<<	" " << outReg.toString()
					<<	", " << sourceVal->toString()
					//terminate the statement
					<<	 ";\n"
					;

				return null() << outReg;
				}
			-| ValueExtract(args, source) ->> {

				//this will just bail
				Nullable<PTXValueRepresentation> sourceVal =
					computeExpression(source,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (!sourceVal)
					return sourceVal;

				PTXValueRepresentation result = *sourceVal;
				for (long k = 0; k < args.size(); k++)
					@match PTXValueRepresentation(result)
						-| Tuple(nt, vals) ->> {
							result = vals[args[k]];
							;}
						-| _ ->> {
							lassert_dump(false, "doesn't make sense");
							;}
					;

				return null() << result;
				}
			-| If(cond, ifTrue, ifFalse) ->> {
				//evaluate 'cond' and then branch. Recombine the values
				//if necessary
				Nullable<PTXValueRepresentation> condVal =
					computeExpression(cond,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (!condVal)
					return condVal;

				//generate jump points
				string	trueBlockName = allocateBlockName("true_");
				string	falseBlockName = allocateBlockName("false_");
				string	rejoinBlockName = allocateBlockName("join_");

				Nullable<PTXValueRepresentation> outReg;
				if (inNativeExpression.type())
					outReg = mRegisters.allocateValue(*inNativeExpression.type());


				string	predicateRegister = mRegisters.allocatePredicate();

				ioSideEffectStream << "setp.ne."
					<< nativeTypeToPTXType(*cond.type()) << " "
					<< predicateRegister << ", "
					<< condVal->toString() << ", "
					<< computeExpression(
							NativeExpression::Zero(*cond.type()),
							inContinuations,
							inEntrypoints,
							inLocalVariables,
							ioSideEffectStream
							)->toString()
					<< ";\n";

				ioSideEffectStream
					<< "@" << predicateRegister << " "
					<< "bra " << trueBlockName << ";\n";

				ioSideEffectStream << "bra " << falseBlockName << ";\n";

				//write the 'true' form
				ioSideEffectStream << trueBlockName << ":\n";
				Nullable<PTXValueRepresentation> trueVal =
					computeExpression(ifTrue,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (trueVal)
					{
					copyFromPTXToPTX(*trueVal, *outReg, ioSideEffectStream);
					ioSideEffectStream << "bra " << rejoinBlockName << ";\n";
					}

				//write the 'false' form
				ioSideEffectStream << falseBlockName << ":\n";
				Nullable<PTXValueRepresentation> falseVal =
					computeExpression(ifFalse,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (falseVal)
					{
					copyFromPTXToPTX(*falseVal, *outReg, ioSideEffectStream);
					ioSideEffectStream << "bra " << rejoinBlockName << ";\n";
					}

				if (trueVal || falseVal)
					{
					ioSideEffectStream << rejoinBlockName << ":\n";
					return outReg;
					}

				return null();
				}
			-| Let(var, expr, within) ->> {

				Nullable<PTXValueRepresentation> val =
					computeExpression(expr,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (!val)
					return val;

				return computeExpression(within,
						inContinuations,
						inEntrypoints,
						inLocalVariables + var + *val,
						ioSideEffectStream
						);
				}
			-| Call(Inline(subCFG, subBlock), handlers, args) ->> {

				//get the args together
				ImmutableTreeVector<PTXValueRepresentation> argVals;

				for (long k = 0; k < args.size();k++)
					{
					Nullable<PTXValueRepresentation> res =
						computeExpression(args[k],
							inContinuations,
							inEntrypoints,
							inLocalVariables,
							ioSideEffectStream
							)
						;

					if (!res)
						return res;

					argVals = argVals + *res;
					}

				//for each handler, allocate a value and a block
				ImmutableTreeVector<PTXContinuationRepresentation> conts;
				for (long k = 0; k < handlers.size(); k++)
					{
					auto varP = inLocalVariables[handlers[k].var()];
					conts = conts +
						PTXContinuationRepresentation(
							(varP) ? *varP : mRegisters.allocateValue(subCFG.returnTypes()[k]),
							allocateBlockName("exit_")
							);
					}
				//evalue the body
				pair<string, PTXEntrypointRepresentation>
					body = computeBody(
									subCFG,
									subBlock,
									conts
									);

				//copy our args into the target
				for (long k = 0; k < args.size(); k++)
					copyFromPTXToPTX(argVals[k], body.second.inputRegisters()[k],
						ioSideEffectStream);

				//jump to the target
				ioSideEffectStream <<
					"bra " << body.second.targetBlock() << ";\n";

				//write the subCFG
				ioSideEffectStream << body.first << "\n";

				//if no continuations have values, then we have no value

				//write a block for each continuation
				if (!inNativeExpression.type())
					{
					//it never returns
					for (long k = 0; k < conts.size();k++)
						{
						ioSideEffectStream << conts[k].targetBlock() << ":\n";
						computeExpression(
							handlers[k].expression(),
							inContinuations,
							inEntrypoints,
							inLocalVariables +
								handlers[k].var() +
								conts[k].targetRegisters(),
							ioSideEffectStream
							);
						}

					return null() << PTXValueRepresentation::Nothing();
					}
					else
					{
					//at least one has an output
					PTXValueRepresentation
						outReg = mRegisters.allocateValue(
										*inNativeExpression.type());

					string	rejoinBlockName = allocateBlockName("rejoin");

					for (long k = 0; k < conts.size(); k++)
						{
						ioSideEffectStream << conts[k].targetBlock() << ":\n";

						Nullable<PTXValueRepresentation> resVal =
							computeExpression(
								handlers[k].expression(),
								inContinuations,
								inEntrypoints,
								inLocalVariables[handlers[k].var()] ?
										inLocalVariables :
										inLocalVariables +
											handlers[k].var() +
											conts[k].targetRegisters(),
								ioSideEffectStream
								);

						if (resVal)
							{
							copyFromPTXToPTX(*resVal, outReg,
								ioSideEffectStream);
							ioSideEffectStream << "bra "
								<< rejoinBlockName << ";\n";
							}
						}

					ioSideEffectStream << rejoinBlockName << ":\n";
					return null() << outReg;
					}
				}
			-| Jump(loc, args) ->> {

				ImmutableTreeVector<PTXValueRepresentation> argVals;

				for (long k = 0; k < args.size();k++)
					{
					Nullable<PTXValueRepresentation> res =
						computeExpression(args[k],
							inContinuations,
							inEntrypoints,
							inLocalVariables,
							ioSideEffectStream
							)
						;

					if (!res)
						return res;

					argVals = argVals + *res;
					}

				for (long k = 0; k < args.size();k++)
					copyFromPTXToPTX(argVals[k],
						inEntrypoints[loc]->inputRegisters()[k],
						ioSideEffectStream
						);

				ioSideEffectStream
					<< "bra "
					<< inEntrypoints[loc]->targetBlock()
					<< ";\n";

				return null() << PTXValueRepresentation::Nothing();
				}
			-| Return(exit, val) ->> {
				Nullable<PTXValueRepresentation> res =
					computeExpression(val,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						)
					;
				if (!res)
					return res;

				copyFromPTXToPTX(
					*res,
					inContinuations[exit].targetRegisters(),
					ioSideEffectStream
					);

				ioSideEffectStream
					<< "bra "
					<< inContinuations[exit].targetBlock()
					<< ";\n"
					;

				return null() << PTXValueRepresentation::Nothing();
				}
			-| Store(address, value) ->> {
				Nullable<PTXValueRepresentation> addrRep =
					computeExpression(address,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);
				if (!addrRep)
					return addrRep;

				Nullable<PTXValueRepresentation> valRep =
					computeExpression(value,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);
				if (!valRep)
					return valRep;

				auto stores = writeValueToPointer(*addrRep, *valRep);
				ioSideEffectStream << stores;
				return null() << PTXValueRepresentation::Nothing();
				}
			-| Load(address, isVolatile) ->> {
				PTXValueRepresentation valRep =
						mRegisters.allocateValue(*inNativeExpression.type());

				Nullable<PTXValueRepresentation> addrRep =
					computeExpression(address,
						inContinuations,
						inEntrypoints,
						inLocalVariables,
						ioSideEffectStream
						);

				auto loads = loadValueFromPointerIntoRegisters(*addrRep, valRep);
				ioSideEffectStream << loads;
				return null() << valRep;
				}
			-| _ ->> {
				throw UnableToConvertToPTX("Invalid native expression: " +
					prettyPrintString(inNativeExpression));
				};

		lassert_dump(false, "should be able to get here. expr = "
			<< prettyPrintString(inNativeExpression));
		return null();
		}
	//move values from one PTX register set to another
	//uses 'mov' commands, and breaks apart tuples
	//will throw exceptions if the two representations
	//don't have the same structure
	void copyFromPTXToPTX(
			PTXValueRepresentation sourceVal,
			PTXValueRepresentation destVal,
			ostringstream& ioSideEffectStream
			)
		{
		@match PTXValueRepresentation(sourceVal)
			-| Nothing() ->> {;}
			-| Constant() ->> {
					lassert(destVal.isAtom());

					ioSideEffectStream
						<< "mov." << destVal.getAtom().ptxType() << "\t\t"
						<< destVal.toString() << ", "
						<< sourceVal.toString()
						<< ";\n";
					;}
			-| Tuple(t, elts) ->> {
					lassert(destVal.isTuple());
					for (long k = 0; k < elts.size();k++)
						copyFromPTXToPTX(
							elts[k],
							destVal.getTuple().elts()[k],
							ioSideEffectStream
							);
					}
			-| Atom() ->> {
					lassert(destVal.isAtom());
					auto sourceAtom = sourceVal.getAtom();
					auto destAtom = destVal.getAtom();
					if (destAtom.registerName().compare(sourceAtom.registerName()))
						{
						ioSideEffectStream
							<< "mov." << destAtom.ptxType() << "\t\t"
							<< destAtom.registerName() << ", "
							<< sourceAtom.registerName()
							<< ";\n";
						}
					;}
			;
		}
	//replace the tuple element in 'value' indexed by 'indices'
	//with 'toInsert'.
	PTXValueRepresentation	rebuildPTXValueWith(
									ImmutableTreeVector<uword_t>	indices,
									PTXValueRepresentation value,
									PTXValueRepresentation toInsert
									)
		{
		lassert(indices.size());

		PTXValueRepresentation rebuilt;

		if (indices.size() == 1)
			rebuilt = toInsert;
			else
			rebuilt = rebuildPTXValueWith(indices.slice(1),
							value.getTuple().elts()[indices[0]],
							toInsert
							);
		return PTXValueRepresentation::Tuple(
			value.getTuple().t(),
			value.getTuple().elts().slice(0,indices[0]) +
				rebuilt +
				value.getTuple().elts().slice(indices[0]+1)
			);
		}


	string					 allocateBlockName(string blockPrefix)
		{
		mBlockIndex++;
		return "$" + blockPrefix + "_" + boost::lexical_cast<string>(mBlockIndex);
		}

	uint32_t				mBlockIndex;	//index used to create unique
											//block names for "bra"
											//instructions
	PTXRegisterAllocator	mRegisters;
	string				  mResult;
	string				  mPtxLibPath;
};

string						computePTXVectorApplyKernelFromNativeCFG(
									const NativeCFG& inCFG,
									const string& entryFunctionName
									)
	{
	//static variables for the conversion cache
	static boost::recursive_mutex*	 s_mutexPtr = 0;
	static map<hash_type,
		Alternative<string, UnableToConvertToPTX> >* s_cachePtr = 0;

	if (!s_mutexPtr)
		{
		s_mutexPtr = new boost::recursive_mutex();
		s_cachePtr = new map<hash_type, Alternative<string, UnableToConvertToPTX> >();
		}

	hash_type hash = hashValue(inCFG);

	//check the cache
		{
		boost::recursive_mutex::scoped_lock lock(*s_mutexPtr);

		if (hash == *s_cachePtr)
			{
			if ((*s_cachePtr)[hash].isLeft())
				return (*s_cachePtr)[hash].left();
			throw (*s_cachePtr)[hash].right();
			}
		}


	try	{
		NativeToPTXConverter	converter(
				inCFG,
				entryFunctionName,
				Runtime::getRuntime().getConfig().ptxLibraryPath());

		//update the cache
			{
			boost::recursive_mutex::scoped_lock lock(*s_mutexPtr);

			(*s_cachePtr)[hash] = converter.getResult();
			return converter.getResult();
			}
		}
	catch(UnableToConvertToPTX e)
		{
		//update the cache
			{
			boost::recursive_mutex::scoped_lock lock(*s_mutexPtr);

			(*s_cachePtr)[hash] = e;
			}
		throw e;
		}
	}

//for the moment, just call computePTXVectorApplyKernelFromNativeCFG
bool						nativeCFGIsValidPTXVectorApplyKernel(
									const NativeCFG& inCFG
									)
	{
	try {
		computePTXVectorApplyKernelFromNativeCFG(inCFG, "dummyKernelName");
		return true;
		}
	catch (UnableToConvertToPTX e)
		{
		return false;
		}
	}
